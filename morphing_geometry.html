<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Morphing Geometry Demo - å‡ ä½•å˜å½¢æ¼”ç¤º</title>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            font-family: 'Arial', sans-serif;
        }
        
        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 16px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 20px;
            backdrop-filter: blur(20px);
            border: 2px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            font-size: 13px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 18px;
            border-radius: 15px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        #shapeInfo {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-width: 200px;
        }
        
        .shape-button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-block;
        }
        
        .shape-button:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }
        
        .shape-button.active {
            background: rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="info">
        <h2>ğŸ”„ å‡ ä½•å˜å½¢æ¼”ç¤º</h2>
        <p>å®æ—¶3Då‡ ä½•ä½“å˜å½¢ä¸æè´¨åŠ¨ç”»</p>
        <div>
            <div class="shape-button active" onclick="morphToShape('sphere')">ğŸ”® çƒä½“</div>
            <div class="shape-button" onclick="morphToShape('cube')">ğŸ“¦ ç«‹æ–¹ä½“</div>
            <div class="shape-button" onclick="morphToShape('cylinder')">ğŸ¥« åœ†æŸ±ä½“</div>
            <div class="shape-button" onclick="morphToShape('torus')">ğŸ© åœ†ç¯</div>
            <div class="shape-button" onclick="morphToShape('octahedron')">ğŸ’ å…«é¢ä½“</div>
        </div>
    </div>
    
    <div id="controls">
        <p><strong>ğŸ® æ§åˆ¶è¯´æ˜:</strong></p>
        <p>ğŸ–±ï¸ æ‹–æ‹½: æ—‹è½¬è§†è§’</p>
        <p>ğŸ” æ»šè½®: ç¼©æ”¾</p>
        <p>âŒ¨ï¸ ç©ºæ ¼: æš‚åœåŠ¨ç”»</p>
        <p>âŒ¨ï¸ C: åˆ‡æ¢é¢œè‰²æ¨¡å¼</p>
        <p>âŒ¨ï¸ W: åˆ‡æ¢çº¿æ¡†æ¨¡å¼</p>
        <p>âŒ¨ï¸ L: åˆ‡æ¢å…‰ç…§</p>
    </div>
    
    <div id="shapeInfo">
        <h4>ğŸ“Š å½“å‰çŠ¶æ€</h4>
        <p>å½¢çŠ¶: <span id="currentShape">çƒä½“</span></p>
        <p>é¡¶ç‚¹æ•°: <span id="vertexCount">0</span></p>
        <p>é¢æ•°: <span id="faceCount">0</span></p>
        <p>å˜å½¢è¿›åº¦: <span id="morphProgress">0%</span></p>
        <p>åŠ¨ç”»é€Ÿåº¦: <span id="animSpeed">1.0x</span></p>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let mesh, currentGeometry, targetGeometry;
        let mouse = new THREE.Vector2();
        let isMouseDown = false;
        let rotationX = 0, rotationY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let time = 0;
        let isPaused = false;
        let morphProgress = 0;
        let isMorphing = false;
        let currentShape = 'sphere';
        let colorMode = 0;
        let wireframeMode = false;
        let lightingEnabled = true;
        let animationSpeed = 1.0;

        // å‡ ä½•ä½“å®šä¹‰
        const geometries = {
            sphere: () => new THREE.SphereGeometry(15, 32, 32),
            cube: () => new THREE.BoxGeometry(20, 20, 20, 8, 8, 8),
            cylinder: () => new THREE.CylinderGeometry(12, 12, 25, 32, 8),
            torus: () => new THREE.TorusGeometry(12, 5, 16, 32),
            octahedron: () => new THREE.OctahedronGeometry(18, 2)
        };

        // å½¢çŠ¶åç§°æ˜ å°„
        const shapeNames = {
            sphere: 'çƒä½“',
            cube: 'ç«‹æ–¹ä½“', 
            cylinder: 'åœ†æŸ±ä½“',
            torus: 'åœ†ç¯',
            octahedron: 'å…«é¢ä½“'
        };

        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 50);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // åˆ›å»ºåˆå§‹å‡ ä½•ä½“
            createMesh();

            // è®¾ç½®å…‰ç…§
            setupLighting();

            // æ·»åŠ äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // å¼€å§‹åŠ¨ç”»
            animate();
        }

        // åˆ›å»ºç½‘æ ¼
        function createMesh() {
            currentGeometry = geometries.sphere();
            
            const material = new THREE.MeshPhongMaterial({
                color: 0xff6b6b,
                shininess: 100,
                transparent: true,
                opacity: 0.9
            });

            mesh = new THREE.Mesh(currentGeometry, material);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            updateShapeInfo();
        }

        // è®¾ç½®å…‰ç…§
        function setupLighting() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);

            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(50, 50, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // è¡¥å…‰
            const fillLight = new THREE.DirectionalLight(0x4ecdc4, 0.3);
            fillLight.position.set(-30, -30, 30);
            scene.add(fillLight);

            // èƒŒå…‰
            const backLight = new THREE.DirectionalLight(0x45b7d1, 0.2);
            backLight.position.set(0, 0, -50);
            scene.add(backLight);
        }

        // å˜å½¢åˆ°æŒ‡å®šå½¢çŠ¶
        function morphToShape(shapeName) {
            if (isMorphing || shapeName === currentShape) return;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.shape-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            targetGeometry = geometries[shapeName]();
            currentShape = shapeName;
            isMorphing = true;
            morphProgress = 0;

            // ç¡®ä¿é¡¶ç‚¹æ•°é‡åŒ¹é…
            const currentPositions = currentGeometry.attributes.position.array;
            const targetPositions = targetGeometry.attributes.position.array;
            
            if (currentPositions.length !== targetPositions.length) {
                // å¦‚æœé¡¶ç‚¹æ•°ä¸åŒ¹é…ï¼Œç›´æ¥æ›¿æ¢
                mesh.geometry.dispose();
                mesh.geometry = targetGeometry;
                currentGeometry = targetGeometry;
                isMorphing = false;
                updateShapeInfo();
                return;
            }

            // å­˜å‚¨åŸå§‹ä½ç½®ç”¨äºæ’å€¼
            mesh.geometry.userData.originalPositions = new Float32Array(currentPositions);
            mesh.geometry.userData.targetPositions = new Float32Array(targetPositions);
        }

        // æ›´æ–°å½¢çŠ¶ä¿¡æ¯
        function updateShapeInfo() {
            document.getElementById('currentShape').textContent = shapeNames[currentShape];
            document.getElementById('vertexCount').textContent = 
                currentGeometry.attributes.position.count;
            document.getElementById('faceCount').textContent = 
                currentGeometry.index ? currentGeometry.index.count / 3 : 
                currentGeometry.attributes.position.count / 3;
            document.getElementById('morphProgress').textContent = 
                Math.round(morphProgress * 100) + '%';
            document.getElementById('animSpeed').textContent = animationSpeed.toFixed(1) + 'x';
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // é¼ æ ‡äº‹ä»¶
            renderer.domElement.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                mouse.x = event.clientX;
                mouse.y = event.clientY;
            });

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    targetRotationY += (event.clientX - mouse.x) * 0.01;
                    targetRotationX += (event.clientY - mouse.y) * 0.01;
                    mouse.x = event.clientX;
                    mouse.y = event.clientY;
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            // æ»šè½®ç¼©æ”¾
            renderer.domElement.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * 0.1;
                camera.position.z = Math.max(20, Math.min(100, camera.position.z));
            });

            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        isPaused = !isPaused;
                        break;
                    case 'KeyC':
                        colorMode = (colorMode + 1) % 5;
                        updateMaterialColor();
                        break;
                    case 'KeyW':
                        wireframeMode = !wireframeMode;
                        mesh.material.wireframe = wireframeMode;
                        break;
                    case 'KeyL':
                        lightingEnabled = !lightingEnabled;
                        scene.children.forEach(child => {
                            if (child.isLight && child.type !== 'AmbientLight') {
                                child.visible = lightingEnabled;
                            }
                        });
                        break;
                    case 'ArrowUp':
                        animationSpeed = Math.min(3.0, animationSpeed + 0.1);
                        break;
                    case 'ArrowDown':
                        animationSpeed = Math.max(0.1, animationSpeed - 0.1);
                        break;
                }
            });

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
        }

        // æ›´æ–°æè´¨é¢œè‰²
        function updateMaterialColor() {
            const colors = [
                0xff6b6b, // çº¢è‰²
                0x4ecdc4, // é’è‰²
                0x45b7d1, // è“è‰²
                0x96ceb4, // ç»¿è‰²
                0xffeaa7  // é»„è‰²
            ];
            mesh.material.color.setHex(colors[colorMode]);
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                time += 0.016 * animationSpeed;

                // å¹³æ»‘æ—‹è½¬
                rotationX += (targetRotationX - rotationX) * 0.1;
                rotationY += (targetRotationY - rotationY) * 0.1;
                mesh.rotation.x = rotationX;
                mesh.rotation.y = rotationY;

                // è‡ªåŠ¨æ—‹è½¬
                mesh.rotation.y += 0.005 * animationSpeed;

                // å¤„ç†å˜å½¢åŠ¨ç”»
                if (isMorphing) {
                    morphProgress += 0.02 * animationSpeed;
                    if (morphProgress >= 1) {
                        morphProgress = 1;
                        isMorphing = false;
                        currentGeometry = targetGeometry;
                    }

                    // æ’å€¼é¡¶ç‚¹ä½ç½®
                    const positions = mesh.geometry.attributes.position.array;
                    const original = mesh.geometry.userData.originalPositions;
                    const target = mesh.geometry.userData.targetPositions;

                    for (let i = 0; i < positions.length; i++) {
                        positions[i] = original[i] + (target[i] - original[i]) * 
                                      easeInOutCubic(morphProgress);
                    }

                    mesh.geometry.attributes.position.needsUpdate = true;
                    mesh.geometry.computeVertexNormals();
                }

                // åŠ¨æ€æè´¨æ•ˆæœ
                const hue = (time * 0.1) % 1;
                const saturation = 0.7 + Math.sin(time * 0.5) * 0.3;
                const lightness = 0.5 + Math.sin(time * 0.3) * 0.2;
                
                if (colorMode === 0) {
                    mesh.material.color.setHSL(hue, saturation, lightness);
                }

                // è„‰å†²æ•ˆæœ
                const scale = 1 + Math.sin(time * 2) * 0.05;
                mesh.scale.setScalar(scale);

                updateShapeInfo();
            }

            renderer.render(scene, camera);
        }

        // ç¼“åŠ¨å‡½æ•°
        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        // å…¨å±€å‡½æ•°ä¾›HTMLè°ƒç”¨
        window.morphToShape = morphToShape;

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>