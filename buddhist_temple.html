<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ›ï¸ Three.js ä¸­å¼ä½›å ‚3Dæ¨¡å‹</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c1810 0%, #8B4513 50%, #DAA520 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #DAA520;
            backdrop-filter: blur(10px);
            min-width: 280px;
        }

        #info h1 {
            color: #DAA520;
            margin-bottom: 10px;
            font-size: 18px;
            text-shadow: 0 0 10px #DAA520;
            text-align: center;
        }

        .info-item {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            color: #DAA520;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #DAA520;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin: 10px 0;
        }

        .control-group label {
            display: block;
            color: #DAA520;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        button {
            background: linear-gradient(45deg, #DAA520, #FFD700);
            border: none;
            color: #8B4513;
            padding: 8px 15px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(218, 165, 32, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(45deg, #FF6347, #FF4500);
            color: white;
            box-shadow: 0 0 20px rgba(255, 99, 71, 0.5);
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #DAA520;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        #instructions h3 {
            color: #DAA520;
            margin-bottom: 10px;
            font-size: 14px;
            text-align: center;
        }

        #instructions ul {
            list-style: none;
            font-size: 11px;
            line-height: 1.4;
        }

        #instructions li {
            margin: 3px 0;
            color: #ccc;
        }

        #instructions .key {
            color: #DAA520;
            font-weight: bold;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            color: #DAA520;
            font-size: 18px;
        }

        .loading.hidden {
            display: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .float {
            animation: float 3s ease-in-out infinite;
        }

        #meditation-timer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 50%;
            border: 3px solid #DAA520;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #meditation-timer .time {
            font-size: 16px;
            font-weight: bold;
            color: #DAA520;
        }

        #meditation-timer .label {
            font-size: 10px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="loading">
            <div class="pulse">ğŸ›ï¸ æ­£åœ¨æ„å»ºä¸­å¼ä½›å ‚...</div>
            <div style="font-size: 12px; margin-top: 10px; color: #aaa;">
                å—æ— é˜¿å¼¥é™€ä½› ğŸ™
            </div>
        </div>

        <div id="info">
            <h1>ğŸ›ï¸ ä¸­å¼ä½›å ‚</h1>
            <div class="info-item">
                <span class="info-label">è§†è§’æ¨¡å¼:</span>
                <span class="info-value" id="cameraMode">è‡ªç”±è§†è§’</span>
            </div>
            <div class="info-item">
                <span class="info-label">é¦™ç«çŠ¶æ€:</span>
                <span class="info-value" id="incenseStatus">ç‡ƒçƒ§ä¸­</span>
            </div>
            <div class="info-item">
                <span class="info-label">ç¯å…‰æ¨¡å¼:</span>
                <span class="info-value" id="lightMode">æ¸©æš–</span>
            </div>
            <div class="info-item">
                <span class="info-label">éŸ³æ•ˆ:</span>
                <span class="info-value" id="soundStatus">å¼€å¯</span>
            </div>
            <div class="info-item">
                <span class="info-label">è²èŠ±çŠ¶æ€:</span>
                <span class="info-value" id="lotusStatus">ç››å¼€</span>
            </div>
            <div class="info-item">
                <span class="info-label">FPS:</span>
                <span class="info-value" id="fps">60</span>
            </div>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>ğŸ¥ è§†è§’æ§åˆ¶</label>
                <button id="cameraFree" class="active">è‡ªç”±è§†è§’</button>
                <button id="cameraFront">æ­£é¢è§†è§’</button>
                <button id="cameraSide">ä¾§é¢è§†è§’</button>
                <button id="cameraTop">ä¿¯è§†è§†è§’</button>
            </div>

            <div class="control-group">
                <label>ğŸ’¡ ç¯å…‰æ°›å›´</label>
                <button id="lightWarm" class="active">æ¸©æš–</button>
                <button id="lightCool">æ¸…å†·</button>
                <button id="lightGolden">é‡‘è¾‰</button>
                <button id="lightCandle">çƒ›å…‰</button>
            </div>

            <div class="control-group">
                <label>ğŸŒ¸ åœºæ™¯å…ƒç´ </label>
                <button id="toggleIncense" class="active">é¦™ç«</button>
                <button id="toggleLotus" class="active">è²èŠ±</button>
                <button id="toggleParticles" class="active">å…‰ç²’</button>
                <button id="toggleSound" class="active">éŸ³æ•ˆ</button>
            </div>

            <div class="control-group">
                <label>ğŸµ èƒŒæ™¯éŸ³ä¹éŸ³é‡: <span id="volumeValue">50%</span></label>
                <input type="range" id="musicVolume" min="0" max="100" value="50">
            </div>
        </div>

        <div id="instructions">
            <h3>ğŸ™ æ“ä½œæŒ‡å—</h3>
            <ul>
                <li><span class="key">é¼ æ ‡æ‹–æ‹½</span> - æ—‹è½¬è§†è§’</li>
                <li><span class="key">æ»šè½®</span> - ç¼©æ”¾è§†è§’</li>
                <li><span class="key">ç©ºæ ¼</span> - å¼€å§‹/åœæ­¢å†¥æƒ³</li>
                <li><span class="key">R</span> - é‡ç½®è§†è§’</li>
                <li><span class="key">1-4</span> - å¿«é€Ÿåˆ‡æ¢è§†è§’</li>
                <li><span class="key">I</span> - åˆ‡æ¢é¦™ç«</li>
                <li><span class="key">L</span> - åˆ‡æ¢è²èŠ±</li>
                <li><span class="key">P</span> - åˆ‡æ¢å…‰ç²’æ•ˆæœ</li>
                <li><span class="key">M</span> - é™éŸ³/å–æ¶ˆé™éŸ³</li>
                <li><span class="key">F</span> - å…¨å±æ¨¡å¼</li>
            </ul>
        </div>

        <div id="meditation-timer">
            <div class="time" id="meditationTime">00:00</div>
            <div class="label">å†¥æƒ³æ—¶é—´</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let currentCameraMode = 'free';
        let currentLightMode = 'warm';
        let isIncenseOn = true;
        let isLotusOn = true;
        let isParticlesOn = true;
        let isSoundOn = true;
        let isMeditating = false;
        let meditationStartTime = 0;
        let frameCount = 0;
        let lastTime = 0;
        let fps = 60;

        // åœºæ™¯å¯¹è±¡
        let buddha, altar, incenseSticks = [], lotusFlowers = [];
        let particles = [], incenseSmoke = [];
        let ambientLight, mainLight, pointLights = [];
        let mouseX = 0, mouseY = 0;

        // éŸ³é¢‘å¯¹è±¡
        let backgroundMusic;
        let isAudioInitialized = false;

        // åˆå§‹åŒ–
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x2c1810, 50, 200);

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 30);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x2c1810);
            document.getElementById('container').appendChild(renderer.domElement);

            // åˆå§‹åŒ–éŸ³é¢‘
            initAudio();

            // è®¾ç½®å…‰ç…§
            setupLighting();

            // åˆ›å»ºä½›å ‚åœºæ™¯
            createTempleScene();

            // è®¾ç½®æ§åˆ¶å™¨
            setupControls();

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // éšè—åŠ è½½ç•Œé¢
            document.getElementById('loading').classList.add('hidden');

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }

        // è®¾ç½®å…‰ç…§
        function setupLighting() {
            // ç¯å¢ƒå…‰
            ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            // ä¸»å…‰æº
            mainLight = new THREE.DirectionalLight(0xffd700, 0.8);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            scene.add(mainLight);

            // ä½›åƒèƒŒå…‰
            const buddhaLight = new THREE.PointLight(0xffd700, 1, 50);
            buddhaLight.position.set(0, 15, -5);
            scene.add(buddhaLight);
            pointLights.push(buddhaLight);

            // èœ¡çƒ›å…‰æº
            for (let i = 0; i < 4; i++) {
                const candleLight = new THREE.PointLight(0xff6600, 0.5, 20);
                const angle = (i / 4) * Math.PI * 2;
                candleLight.position.set(Math.cos(angle) * 8, 3, Math.sin(angle) * 8);
                scene.add(candleLight);
                pointLights.push(candleLight);
            }
        }

        // åˆå§‹åŒ–éŸ³é¢‘ç³»ç»Ÿ
        function initAudio() {
            try {
                // åˆ›å»ºéŸ³é¢‘å…ƒç´ 
                backgroundMusic = new Audio('180469__soniaespi__echo-in-a-buddhist-temple.wav');
                backgroundMusic.loop = true;
                backgroundMusic.volume = 0.5;
                backgroundMusic.preload = 'auto';
                
                console.log('éŸ³é¢‘æ–‡ä»¶åŠ è½½æˆåŠŸ');
                isAudioInitialized = true;
                
                // æ·»åŠ éŸ³é¢‘äº‹ä»¶ç›‘å¬
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('éŸ³é¢‘å¯ä»¥æ’­æ”¾');
                });
                
                backgroundMusic.addEventListener('error', (e) => {
                    console.error('éŸ³é¢‘åŠ è½½é”™è¯¯:', e);
                });
                
                // æ·»åŠ æµ‹è¯•æŒ‰é’®
                addAudioTestButton();
            } catch (error) {
                console.warn('éŸ³é¢‘åˆå§‹åŒ–å¤±è´¥:', error);
                isAudioInitialized = false;
            }
        }

        // æ·»åŠ éŸ³é¢‘æµ‹è¯•æŒ‰é’®
        function addAudioTestButton() {
            const testButton = document.createElement('button');
            testButton.textContent = 'æ’­æ”¾éŸ³ä¹';
            testButton.style.position = 'fixed';
            testButton.style.top = '10px';
            testButton.style.right = '10px';
            testButton.style.zIndex = '1000';
            testButton.style.padding = '10px';
            testButton.style.backgroundColor = '#4CAF50';
            testButton.style.color = 'white';
            testButton.style.border = 'none';
            testButton.style.borderRadius = '5px';
            testButton.style.cursor = 'pointer';
            
            testButton.addEventListener('click', async () => {
                if (backgroundMusic.paused) {
                    try {
                        await backgroundMusic.play();
                        testButton.textContent = 'æš‚åœéŸ³ä¹';
                        testButton.style.backgroundColor = '#f44336';
                        console.log('å¼€å§‹æ’­æ”¾ä½›æ•™éŸ³ä¹');
                    } catch (error) {
                        console.error('æ’­æ”¾å¤±è´¥:', error);
                    }
                } else {
                    backgroundMusic.pause();
                    testButton.textContent = 'æ’­æ”¾éŸ³ä¹';
                    testButton.style.backgroundColor = '#4CAF50';
                    console.log('æš‚åœä½›æ•™éŸ³ä¹');
                }
            });
            
            document.body.appendChild(testButton);
        }

        // è®¾ç½®éŸ³ä¹éŸ³é‡
        function setMusicVolume(volume) {
            if (backgroundMusic) {
                backgroundMusic.volume = volume / 100;
            }
        }

        // åˆ›å»ºä½›å ‚åœºæ™¯
        function createTempleScene() {
            // åˆ›å»ºåœ°é¢
            createFloor();

            // åˆ›å»ºå¢™å£
            createWalls();

            // åˆ›å»ºä½›å°
            createAltar();

            // åˆ›å»ºä½›åƒ
            createBuddha();

            // åˆ›å»ºé¦™ç‚‰å’Œé¦™
            createIncense();

            // åˆ›å»ºè²èŠ±
            createLotusFlowers();

            // åˆ›å»ºè’²å›¢
            createCushions();

            // åˆ›å»ºè£…é¥°å“
            createDecorations();

            // åˆ›å»ºç²’å­æ•ˆæœ
            createParticleEffects();
        }

        // åˆ›å»ºåœ°é¢
        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(60, 60);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // åœ°é¢èŠ±çº¹
            const patternGeometry = new THREE.RingGeometry(5, 15, 8);
            const patternMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xDAA520,
                transparent: true,
                opacity: 0.3
            });
            const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
            pattern.rotation.x = -Math.PI / 2;
            pattern.position.y = 0.01;
            scene.add(pattern);
        }

        // åˆ›å»ºå¢™å£
        function createWalls() {
            const wallHeight = 20;
            const wallWidth = 60;

            // åå¢™
            const backWallGeometry = new THREE.PlaneGeometry(wallWidth, wallHeight);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, wallHeight/2, -30);
            backWall.receiveShadow = true;
            scene.add(backWall);

            // ä¾§å¢™
            const sideWallGeometry = new THREE.PlaneGeometry(wallWidth, wallHeight);
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.set(-30, wallHeight/2, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.set(30, wallHeight/2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            // å¢™ä¸Šè£…é¥°
            createWallDecorations();
        }

        // åˆ›å»ºå¢™é¢è£…é¥°
        function createWallDecorations() {
            // ä½›æ•™ç¬¦å·
            const symbolGeometry = new THREE.CircleGeometry(2, 8);
            const symbolMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xDAA520,
                transparent: true,
                opacity: 0.8
            });

            for (let i = 0; i < 3; i++) {
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.position.set((i - 1) * 8, 12, -29.9);
                scene.add(symbol);
            }
        }

        // åˆ›å»ºä½›å°
        function createAltar() {
            altar = new THREE.Group();

            // ä½›å°åº•åº§
            const baseGeometry = new THREE.BoxGeometry(16, 2, 8);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1;
            base.castShadow = true;
            base.receiveShadow = true;
            altar.add(base);

            // ä½›å°å°é¢
            const topGeometry = new THREE.BoxGeometry(18, 0.5, 10);
            const topMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 2.25;
            top.castShadow = true;
            top.receiveShadow = true;
            altar.add(top);

            altar.position.set(0, 0, -15);
            scene.add(altar);
        }

        // åˆ›å»ºä½›åƒ
        function createBuddha() {
            buddha = new THREE.Group();

            // åˆ›å»ºç²¾ç»†çš„è²èŠ±åº§
            createDetailedLotusBase();

            // åˆ›å»ºç›˜è…¿åå§¿çš„è…¿éƒ¨
            createBuddhaLegs();

            // ä½›åƒèº«ä½“ - ç«¯æ­£æŒºç›´çš„èº¯å¹²
            const bodyGeometry = new THREE.CylinderGeometry(1.4, 1.6, 4.5, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150,
                specular: 0x444444
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 4.5;
            body.castShadow = true;
            buddha.add(body);

            // ä½›åƒè‚©è†€ - å®½é˜”çš„è‚©è†€
            const shoulderGeometry = new THREE.CylinderGeometry(1.8, 1.4, 1, 16);
            const shoulder = new THREE.Mesh(shoulderGeometry, bodyMaterial);
            shoulder.position.y = 6.2;
            shoulder.castShadow = true;
            buddha.add(shoulder);

            // ä½›åƒèƒ¸éƒ¨è£…é¥° - åº„ä¸¥çš„æ³•è½®
            const chestOrnamentGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
            const chestOrnamentMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFF6347,
                shininess: 200,
                emissive: 0x220000
            });
            const chestOrnament = new THREE.Mesh(chestOrnamentGeometry, chestOrnamentMaterial);
            chestOrnament.position.set(0, 5.8, 1.3);
            buddha.add(chestOrnament);

            // ä½›åƒå¤´éƒ¨ - æ›´ç²¾ç»†
            const headGeometry = new THREE.SphereGeometry(1.2, 20, 20);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150,
                specular: 0x333333
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 7.8;
            head.castShadow = true;
            buddha.add(head);

            // ä½›åƒé¢éƒ¨ç‰¹å¾
            createBuddhaFace();

            // ä½›åƒæ‰‹è‡‚ - æ‰“åæ‰‹å°
            createMeditationArms();

            // ä½›åƒæœé¥°è¤¶çš±
            createBuddhaRobes();

            // å¢å¼ºç‰ˆå…‰ç¯
            createEnhancedHalo();

            // å¤´é¡¶è‚‰é«»
            const topKnotGeometry = new THREE.SphereGeometry(0.4, 12, 12);
            const topKnotMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xB8860B,
                shininess: 100
            });
            const topKnot = new THREE.Mesh(topKnotGeometry, topKnotMaterial);
            topKnot.position.set(0, 8.8, 0);
            topKnot.castShadow = true;
            buddha.add(topKnot);

            buddha.position.set(0, 2.5, -15);
            scene.add(buddha);
        }

        // åˆ›å»ºç›˜è…¿åå§¿
        function createBuddhaLegs() {
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });

            // å·¦è…¿ - ç›˜è…¿å§¿åŠ¿
            const leftThighGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.5, 12);
            const leftThigh = new THREE.Mesh(leftThighGeometry, legMaterial);
            leftThigh.position.set(-1.2, 2.8, 0.5);
            leftThigh.rotation.z = Math.PI / 6;
            leftThigh.rotation.x = Math.PI / 3;
            leftThigh.castShadow = true;
            buddha.add(leftThigh);

            const leftCalfGeometry = new THREE.CylinderGeometry(0.5, 0.6, 2, 12);
            const leftCalf = new THREE.Mesh(leftCalfGeometry, legMaterial);
            leftCalf.position.set(-2, 2, 1.8);
            leftCalf.rotation.z = Math.PI / 4;
            leftCalf.rotation.x = Math.PI / 2;
            leftCalf.castShadow = true;
            buddha.add(leftCalf);

            // å³è…¿ - ç›˜è…¿å§¿åŠ¿
            const rightThigh = new THREE.Mesh(leftThighGeometry, legMaterial);
            rightThigh.position.set(1.2, 2.8, 0.5);
            rightThigh.rotation.z = -Math.PI / 6;
            rightThigh.rotation.x = Math.PI / 3;
            rightThigh.castShadow = true;
            buddha.add(rightThigh);

            const rightCalf = new THREE.Mesh(leftCalfGeometry, legMaterial);
            rightCalf.position.set(2, 2, 1.8);
            rightCalf.rotation.z = -Math.PI / 4;
            rightCalf.rotation.x = Math.PI / 2;
            rightCalf.castShadow = true;
            buddha.add(rightCalf);

            // è„šéƒ¨
            const footGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const leftFoot = new THREE.Mesh(footGeometry, legMaterial);
            leftFoot.position.set(-2.8, 1.8, 2.2);
            leftFoot.scale.set(1.2, 0.6, 1.5);
            leftFoot.castShadow = true;
            buddha.add(leftFoot);

            const rightFoot = new THREE.Mesh(footGeometry, legMaterial);
            rightFoot.position.set(2.8, 1.8, 2.2);
            rightFoot.scale.set(1.2, 0.6, 1.5);
            rightFoot.castShadow = true;
            buddha.add(rightFoot);
        }

        // åˆ›å»ºç¦…å®šæ‰‹å°çš„æ‰‹è‡‚
        function createMeditationArms() {
            const armMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });

            // å·¦è‡‚ - è‡ªç„¶ä¸‹å‚
            const leftUpperArmGeometry = new THREE.CylinderGeometry(0.4, 0.5, 2.5, 8);
            const leftUpperArm = new THREE.Mesh(leftUpperArmGeometry, armMaterial);
            leftUpperArm.position.set(-1.8, 5.5, 0);
            leftUpperArm.rotation.z = Math.PI / 8;
            leftUpperArm.castShadow = true;
            buddha.add(leftUpperArm);

            const leftForearmGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const leftForearm = new THREE.Mesh(leftForearmGeometry, armMaterial);
            leftForearm.position.set(-1.2, 3.8, 1.2);
            leftForearm.rotation.z = Math.PI / 6;
            leftForearm.rotation.x = -Math.PI / 4;
            leftForearm.castShadow = true;
            buddha.add(leftForearm);

            // å³è‡‚ - è‡ªç„¶ä¸‹å‚
            const rightUpperArm = new THREE.Mesh(leftUpperArmGeometry, armMaterial);
            rightUpperArm.position.set(1.8, 5.5, 0);
            rightUpperArm.rotation.z = -Math.PI / 8;
            rightUpperArm.castShadow = true;
            buddha.add(rightUpperArm);

            const rightForearm = new THREE.Mesh(leftForearmGeometry, armMaterial);
            rightForearm.position.set(1.2, 3.8, 1.2);
            rightForearm.rotation.z = -Math.PI / 6;
            rightForearm.rotation.x = -Math.PI / 4;
            rightForearm.castShadow = true;
            buddha.add(rightForearm);

            // ç¦…å®šæ‰‹å° - åŒæ‰‹åˆåäºè…¹å‰
            const handGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const handMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });

            // å·¦æ‰‹
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-0.3, 3.2, 2);
            leftHand.scale.set(0.8, 1.2, 0.6);
            leftHand.rotation.y = Math.PI / 6;
            leftHand.castShadow = true;
            buddha.add(leftHand);

            // å³æ‰‹
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0.3, 3.2, 2);
            rightHand.scale.set(0.8, 1.2, 0.6);
            rightHand.rotation.y = -Math.PI / 6;
            rightHand.castShadow = true;
            buddha.add(rightHand);

            // æ‰‹æŒ‡ç»†èŠ‚ - ç¦…å®šå°
            for (let i = 0; i < 5; i++) {
                const fingerGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6);
                const fingerMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
                
                // å·¦æ‰‹æ‰‹æŒ‡
                const leftFinger = new THREE.Mesh(fingerGeometry, fingerMaterial);
                leftFinger.position.set(-0.3 + (i - 2) * 0.1, 3.8, 2.2);
                leftFinger.rotation.x = Math.PI / 12;
                buddha.add(leftFinger);

                // å³æ‰‹æ‰‹æŒ‡
                const rightFinger = new THREE.Mesh(fingerGeometry, fingerMaterial);
                rightFinger.position.set(0.3 + (i - 2) * 0.1, 3.8, 2.2);
                rightFinger.rotation.x = Math.PI / 12;
                buddha.add(rightFinger);
            }

            buddha.position.set(0, 2.5, -15);
            scene.add(buddha);
        }

        // åˆ›å»ºç²¾ç»†çš„è²èŠ±åº§
        function createDetailedLotusBase() {
            // è²èŠ±åº§åº•åº§
            const baseGeometry = new THREE.CylinderGeometry(3.5, 4, 1.5, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x228B22,
                shininess: 80
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.75;
            base.castShadow = true;
            buddha.add(base);

            // å¤šå±‚è²èŠ±èŠ±ç“£
            for (let layer = 0; layer < 3; layer++) {
                const petalCount = 8 + layer * 4;
                const radius = 2.5 + layer * 0.5;
                const height = 1.5 + layer * 0.3;
                
                for (let i = 0; i < petalCount; i++) {
                    const petalGeometry = new THREE.SphereGeometry(0.6, 8, 8);
                    const petalMaterial = new THREE.MeshPhongMaterial({ 
                        color: layer === 0 ? 0xFF1493 : layer === 1 ? 0xFF69B4 : 0xFFB6C1,
                        transparent: true,
                        opacity: 0.9,
                        shininess: 100
                    });
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    const angle = (i / petalCount) * Math.PI * 2 + layer * 0.2;
                    petal.position.set(
                        Math.cos(angle) * radius, 
                        height, 
                        Math.sin(angle) * radius
                    );
                    petal.scale.set(0.8, 0.4, 1.2);
                    petal.rotation.y = angle;
                    petal.rotation.x = -0.3;
                    petal.castShadow = true;
                    buddha.add(petal);
                }
            }

            // è²èŠ±ä¸­å¿ƒ
            const centerGeometry = new THREE.SphereGeometry(0.5, 12, 12);
            const centerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                transparent: true,
                opacity: 0.8
            });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 2;
            buddha.add(center);
        }

        // åˆ›å»ºä½›åƒé¢éƒ¨ç‰¹å¾
        function createBuddhaFace() {
            // çœ¼ç›
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 8.7, 1.1);
            buddha.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 8.7, 1.1);
            buddha.add(rightEye);

            // çœ‰æ¯›
            const eyebrowGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 6);
            const eyebrowMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(-0.3, 9, 1.1);
            leftEyebrow.rotation.z = Math.PI / 2;
            buddha.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(0.3, 9, 1.1);
            rightEyebrow.rotation.z = Math.PI / 2;
            buddha.add(rightEyebrow);

            // é¼»å­
            const noseGeometry = new THREE.ConeGeometry(0.1, 0.3, 6);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 8.3, 1.2);
            nose.rotation.x = Math.PI;
            buddha.add(nose);

            // å˜´å”‡ - å¾®ç¬‘
            const mouthGeometry = new THREE.TorusGeometry(0.2, 0.05, 4, 8, Math.PI);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0xB8860B });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 7.9, 1.1);
            mouth.rotation.x = Math.PI;
            buddha.add(mouth);
        }

        // åˆ›å»ºä½›åƒæ‰‹è‡‚
        function createBuddhaArms() {
            // å·¦è‡‚
            const leftArmGeometry = new THREE.CylinderGeometry(0.4, 0.5, 3, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });
            const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
            leftArm.position.set(-2.2, 6, 0);
            leftArm.rotation.z = Math.PI / 6;
            leftArm.castShadow = true;
            buddha.add(leftArm);

            // å³è‡‚
            const rightArm = new THREE.Mesh(leftArmGeometry, armMaterial);
            rightArm.position.set(2.2, 6, 0);
            rightArm.rotation.z = -Math.PI / 6;
            rightArm.castShadow = true;
            buddha.add(rightArm);

            // å·¦æ‰‹ - æ–½æ— ç•å°
            const leftHandGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const handMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });
            const leftHand = new THREE.Mesh(leftHandGeometry, handMaterial);
            leftHand.position.set(-3, 4.5, 1);
            leftHand.castShadow = true;
            buddha.add(leftHand);

            // å³æ‰‹ - ä¸æ„¿å°
            const rightHand = new THREE.Mesh(leftHandGeometry, handMaterial);
            rightHand.position.set(3, 4.5, 1);
            rightHand.castShadow = true;
            buddha.add(rightHand);

            // æ‰‹æŒ‡ç»†èŠ‚
            for (let hand = 0; hand < 2; hand++) {
                const handX = hand === 0 ? -3 : 3;
                for (let finger = 0; finger < 5; finger++) {
                    const fingerGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
                    const fingerMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
                    const fingerMesh = new THREE.Mesh(fingerGeometry, fingerMaterial);
                    fingerMesh.position.set(
                        handX + (finger - 2) * 0.15,
                        4.8,
                        1.3
                    );
                    fingerMesh.castShadow = true;
                    buddha.add(fingerMesh);
                }
            }
        }

        // åˆ›å»ºä½›åƒæœé¥°è¤¶çš±
        function createBuddhaRobes() {
            // è¢ˆè£Ÿè¤¶çš±
            for (let i = 0; i < 6; i++) {
                const foldGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4, 6);
                const foldMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xB8860B,
                    transparent: true,
                    opacity: 0.8
                });
                const fold = new THREE.Mesh(foldGeometry, foldMaterial);
                const angle = (i / 6) * Math.PI * 2;
                fold.position.set(
                    Math.cos(angle) * 1.5,
                    5,
                    Math.sin(angle) * 1.5
                );
                fold.rotation.x = Math.PI / 2;
                fold.rotation.y = angle;
                buddha.add(fold);
            }

            // è…°å¸¦
            const beltGeometry = new THREE.TorusGeometry(2, 0.2, 8, 16);
            const beltMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000,
                shininess: 100
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 4;
            belt.rotation.x = Math.PI / 2;
            buddha.add(belt);
        }

        // åˆ›å»ºå¢å¼ºç‰ˆå…‰ç¯
        function createEnhancedHalo() {
            // ä¸»å…‰ç¯
            const haloGeometry = new THREE.RingGeometry(2.5, 3.5, 32);
            const haloMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.set(0, 9, -1);
            buddha.add(halo);

            // å†…å±‚å…‰ç¯
            const innerHaloGeometry = new THREE.RingGeometry(1.8, 2.3, 24);
            const innerHaloMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const innerHalo = new THREE.Mesh(innerHaloGeometry, innerHaloMaterial);
            innerHalo.position.set(0, 9, -0.8);
            buddha.add(innerHalo);

            // å…‰ç¯è£…é¥°
            for (let i = 0; i < 12; i++) {
                const ornamentGeometry = new THREE.SphereGeometry(0.1, 6, 6);
                const ornamentMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.9
                });
                const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterial);
                const angle = (i / 12) * Math.PI * 2;
                ornament.position.set(
                    Math.cos(angle) * 3,
                    9,
                    Math.sin(angle) * 3 - 1
                );
                buddha.add(ornament);
            }

            // å…‰ç¯å‘å…‰æ•ˆæœ
            const glowGeometry = new THREE.RingGeometry(3.5, 4.5, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(0, 9, -1.2);
            buddha.add(glow);
        }

        // åˆ›å»ºé¦™ç‚‰å’Œé¦™
        function createIncense() {
            // é¦™ç‚‰
            const incenseHolderGeometry = new THREE.CylinderGeometry(2, 2.5, 1.5, 8);
            const incenseHolderMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const incenseHolder = new THREE.Mesh(incenseHolderGeometry, incenseHolderMaterial);
            incenseHolder.position.set(0, 3.25, -10);
            incenseHolder.castShadow = true;
            scene.add(incenseHolder);

            // é¦™
            for (let i = 0; i < 5; i++) {
                const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 8);
                const stickMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
                const stick = new THREE.Mesh(stickGeometry, stickMaterial);
                stick.position.set((i - 2) * 0.3, 5.25, -10);
                stick.castShadow = true;
                scene.add(stick);
                incenseSticks.push(stick);

                // é¦™ç«é¡¶ç«¯
                const fireGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const fireMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff4500,
                    transparent: true,
                    opacity: 0.8
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.set((i - 2) * 0.3, 7.25, -10);
                scene.add(fire);
            }

            // åˆ›å»ºé¦™çƒŸæ•ˆæœ
            createIncenseSmoke();
        }

        // åˆ›å»ºé¦™çƒŸæ•ˆæœ
        function createIncenseSmoke() {
            for (let i = 0; i < 5; i++) {
                const smokeGeometry = new THREE.BufferGeometry();
                const smokeMaterial = new THREE.PointsMaterial({
                    color: 0xcccccc,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.3
                });

                const smokeVertices = [];
                for (let j = 0; j < 20; j++) {
                    smokeVertices.push(
                        (i - 2) * 0.3 + (Math.random() - 0.5) * 0.5,
                        7.25 + j * 0.5,
                        -10 + (Math.random() - 0.5) * 0.5
                    );
                }

                smokeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(smokeVertices, 3));
                const smoke = new THREE.Points(smokeGeometry, smokeMaterial);
                scene.add(smoke);
                incenseSmoke.push(smoke);
            }
        }

        // åˆ›å»ºè²èŠ±
        function createLotusFlowers() {
            const positions = [
                { x: -8, z: -5 },
                { x: 8, z: -5 },
                { x: -12, z: 5 },
                { x: 12, z: 5 },
                { x: 0, z: 10 }
            ];

            positions.forEach((pos, index) => {
                const lotus = createSingleLotus();
                lotus.position.set(pos.x, 0.5, pos.z);
                scene.add(lotus);
                lotusFlowers.push(lotus);
            });
        }

        // åˆ›å»ºå•æœµè²èŠ±
        function createSingleLotus() {
            const lotus = new THREE.Group();

            // è²èŠ±åº•åº§
            const baseGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 8);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            lotus.add(base);

            // è²èŠ±èŠ±ç“£
            for (let i = 0; i < 8; i++) {
                const petalGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                const petalMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFF69B4,
                    transparent: true,
                    opacity: 0.8
                });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                const angle = (i / 8) * Math.PI * 2;
                petal.position.set(Math.cos(angle) * 0.8, 0.5, Math.sin(angle) * 0.8);
                petal.scale.set(0.5, 0.3, 1);
                petal.castShadow = true;
                lotus.add(petal);
            }

            // è²èŠ±ä¸­å¿ƒ
            const centerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const centerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 0.5;
            lotus.add(center);

            return lotus;
        }

        // åˆ›å»ºè’²å›¢
        function createCushions() {
            const positions = [
                { x: -6, z: 8 },
                { x: 0, z: 12 },
                { x: 6, z: 8 }
            ];

            positions.forEach(pos => {
                const cushionGeometry = new THREE.CylinderGeometry(2, 2, 0.5, 16);
                const cushionMaterial = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
                const cushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
                cushion.position.set(pos.x, 0.25, pos.z);
                cushion.castShadow = true;
                cushion.receiveShadow = true;
                scene.add(cushion);
            });
        }

        // åˆ›å»ºè£…é¥°å“
        function createDecorations() {
            // èŠ±ç“¶
            const vasePositions = [
                { x: -6, z: -12 },
                { x: 6, z: -12 }
            ];

            vasePositions.forEach(pos => {
                const vaseGeometry = new THREE.CylinderGeometry(1, 1.5, 4, 8);
                const vaseMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
                const vase = new THREE.Mesh(vaseGeometry, vaseMaterial);
                vase.position.set(pos.x, 4.5, pos.z);
                vase.castShadow = true;
                scene.add(vase);
            });

            // ç»ä¹¦
            const bookGeometry = new THREE.BoxGeometry(2, 0.3, 3);
            const bookMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const book = new THREE.Mesh(bookGeometry, bookMaterial);
            book.position.set(-4, 2.75, -10);
            book.castShadow = true;
            scene.add(book);

            // æœ¨é±¼
            const woodenFishGeometry = new THREE.SphereGeometry(1, 8, 8);
            const woodenFishMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const woodenFish = new THREE.Mesh(woodenFishGeometry, woodenFishMaterial);
            woodenFish.position.set(4, 2.75, -10);
            woodenFish.scale.set(1, 0.6, 1);
            woodenFish.castShadow = true;
            scene.add(woodenFish);
        }

        // åˆ›å»ºç²’å­æ•ˆæœ
        function createParticleEffects() {
            // é‡‘è‰²å…‰ç²’
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffd700,
                size: 0.3,
                transparent: true,
                opacity: 0.6
            });

            const particleVertices = [];
            for (let i = 0; i < 100; i++) {
                particleVertices.push(
                    (Math.random() - 0.5) * 40,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 40
                );
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        // è®¾ç½®æ§åˆ¶å™¨
        function setupControls() {
            // ç®€å•çš„é¼ æ ‡æ§åˆ¶
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging && currentCameraMode === 'free') {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };

                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(deltaMove.y * 0.5),
                            toRadians(deltaMove.x * 0.5),
                            0,
                            'XYZ'
                        ));

                    camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // æ»šè½®ç¼©æ”¾
            renderer.domElement.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.1;
                const direction = e.deltaY > 0 ? 1 : -1;
                camera.position.multiplyScalar(1 + direction * zoomSpeed);
            });
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', onKeyDown);

            // æŒ‰é’®äº‹ä»¶
            setupButtonEvents();

            // æ»‘å—äº‹ä»¶
            document.getElementById('musicVolume').addEventListener('input', (e) => {
                const volume = parseInt(e.target.value);
                document.getElementById('volumeValue').textContent = volume + '%';
                setMusicVolume(volume);
            });

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);

            // ç‚¹å‡»ä½›åƒæ’­æ”¾é’Ÿå£°
            renderer.domElement.addEventListener('click', (event) => {
                // é¦–æ¬¡ç”¨æˆ·äº¤äº’æ—¶å¯åŠ¨éŸ³é¢‘ä¸Šä¸‹æ–‡
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                if (buddha) {
                    const intersects = raycaster.intersectObject(buddha, true);
                    if (intersects.length > 0) {
                        // ç‚¹å‡»ä½›åƒæ—¶çš„ç‰¹æ®Šæ•ˆæœ
                        triggerBuddhaClickEffect();
                        
                        // æ’­æ”¾èƒŒæ™¯éŸ³ä¹
                        if (backgroundMusic && backgroundMusic.paused && isSoundOn) {
                            backgroundMusic.play().catch(console.error);
                        }
                    }
                }
            });

            // ç§»é™¤å®šæœŸæ’­æ”¾ç¯å¢ƒéŸ³æ•ˆçš„é€»è¾‘ï¼Œå› ä¸ºç°åœ¨åªæ’­æ”¾èƒŒæ™¯éŸ³ä¹
        }

        // è®¾ç½®æŒ‰é’®äº‹ä»¶
        function setupButtonEvents() {
            // è§†è§’æ§åˆ¶
            document.getElementById('cameraFree').addEventListener('click', () => setCameraMode('free'));
            document.getElementById('cameraFront').addEventListener('click', () => setCameraMode('front'));
            document.getElementById('cameraSide').addEventListener('click', () => setCameraMode('side'));
            document.getElementById('cameraTop').addEventListener('click', () => setCameraMode('top'));

            // ç¯å…‰æ§åˆ¶
            document.getElementById('lightWarm').addEventListener('click', () => setLightMode('warm'));
            document.getElementById('lightCool').addEventListener('click', () => setLightMode('cool'));
            document.getElementById('lightGolden').addEventListener('click', () => setLightMode('golden'));
            document.getElementById('lightCandle').addEventListener('click', () => setLightMode('candle'));

            // åœºæ™¯å…ƒç´ æ§åˆ¶
            document.getElementById('toggleIncense').addEventListener('click', toggleIncense);
            document.getElementById('toggleLotus').addEventListener('click', toggleLotus);
            document.getElementById('toggleParticles').addEventListener('click', toggleParticles);
            document.getElementById('toggleSound').addEventListener('click', toggleSound);
        }

        // é”®ç›˜äº‹ä»¶å¤„ç†
        function onKeyDown(event) {
            switch(event.code) {
                case 'Space':
                    event.preventDefault();
                    toggleMeditation();
                    break;
                case 'KeyR':
                    resetCamera();
                    break;
                case 'Digit1':
                    setCameraMode('free');
                    break;
                case 'Digit2':
                    setCameraMode('front');
                    break;
                case 'Digit3':
                    setCameraMode('side');
                    break;
                case 'Digit4':
                    setCameraMode('top');
                    break;
                case 'KeyI':
                    toggleIncense();
                    break;
                case 'KeyL':
                    toggleLotus();
                    break;
                case 'KeyP':
                    toggleParticles();
                    break;
                case 'KeyM':
                    toggleSound();
                    break;
                case 'KeyF':
                    toggleFullscreen();
                    break;
            }
        }

        // è®¾ç½®ç›¸æœºæ¨¡å¼
        function setCameraMode(mode) {
            currentCameraMode = mode;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('#controls button').forEach(btn => {
                if (btn.id.includes('camera')) {
                    btn.classList.remove('active');
                }
            });
            
            const modeNames = {
                'free': 'è‡ªç”±è§†è§’',
                'front': 'æ­£é¢è§†è§’',
                'side': 'ä¾§é¢è§†è§’',
                'top': 'ä¿¯è§†è§†è§’'
            };
            
            document.getElementById('camera' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
            document.getElementById('cameraMode').textContent = modeNames[mode];

            // è®¾ç½®ç›¸æœºä½ç½®
            switch(mode) {
                case 'front':
                    camera.position.set(0, 10, 25);
                    camera.lookAt(0, 5, -15);
                    break;
                case 'side':
                    camera.position.set(25, 10, 0);
                    camera.lookAt(0, 5, -15);
                    break;
                case 'top':
                    camera.position.set(0, 40, 0);
                    camera.lookAt(0, 0, -15);
                    break;
                case 'free':
                default:
                    camera.position.set(0, 15, 30);
                    camera.lookAt(0, 5, -15);
                    break;
            }
        }

        // è®¾ç½®ç¯å…‰æ¨¡å¼
        function setLightMode(mode) {
            currentLightMode = mode;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('#controls button').forEach(btn => {
                if (btn.id.includes('light')) {
                    btn.classList.remove('active');
                }
            });
            
            document.getElementById('light' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');

            const modeNames = {
                'warm': 'æ¸©æš–',
                'cool': 'æ¸…å†·',
                'golden': 'é‡‘è¾‰',
                'candle': 'çƒ›å…‰'
            };
            
            document.getElementById('lightMode').textContent = modeNames[mode];

            // è°ƒæ•´å…‰ç…§é¢œè‰²ã€å¼ºåº¦å’Œé›¾æ•ˆ
            switch(mode) {
                case 'warm':
                    // æ¸©æš–æ¨¡å¼ - æš–é»„è‰²è°ƒ
                    ambientLight.color.setHex(0x604040);
                    ambientLight.intensity = 0.4;
                    mainLight.color.setHex(0xffd700);
                    mainLight.intensity = 0.8;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0xffd700);
                        light.intensity = index === 0 ? 1.2 : 0.6; // ä½›åƒèƒŒå…‰æ›´äº®
                    });
                    scene.fog.color.setHex(0x3c2010);
                    renderer.setClearColor(0x3c2010);
                    break;
                    
                case 'cool':
                    // æ¸…å†·æ¨¡å¼ - è“ç™½è‰²è°ƒ
                    ambientLight.color.setHex(0x404060);
                    ambientLight.intensity = 0.5;
                    mainLight.color.setHex(0x87ceeb);
                    mainLight.intensity = 0.9;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0x87ceeb);
                        light.intensity = index === 0 ? 1.0 : 0.8;
                    });
                    scene.fog.color.setHex(0x1a1a2e);
                    renderer.setClearColor(0x1a1a2e);
                    break;
                    
                case 'golden':
                    // é‡‘è¾‰æ¨¡å¼ - å¼ºçƒˆé‡‘è‰²
                    ambientLight.color.setHex(0x806040);
                    ambientLight.intensity = 0.6;
                    mainLight.color.setHex(0xffd700);
                    mainLight.intensity = 1.2;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0xffd700);
                        light.intensity = index === 0 ? 1.5 : 0.9; // æ›´å¼ºçš„é‡‘è‰²å…‰èŠ’
                    });
                    scene.fog.color.setHex(0x4a3520);
                    renderer.setClearColor(0x4a3520);
                    break;
                    
                case 'candle':
                    // çƒ›å…‰æ¨¡å¼ - æ˜æš—æ©™çº¢è‰²
                    ambientLight.color.setHex(0x302020);
                    ambientLight.intensity = 0.2;
                    mainLight.color.setHex(0xff4400);
                    mainLight.intensity = 0.4;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0xff4400);
                        light.intensity = index === 0 ? 0.8 : 0.4; // æ›´æš—çš„çƒ›å…‰æ•ˆæœ
                    });
                    scene.fog.color.setHex(0x2a1510);
                    renderer.setClearColor(0x2a1510);
                    break;
            }
            
            console.log(`åˆ‡æ¢åˆ°${modeNames[mode]}æ¨¡å¼`);
        }

        // ä½›åƒç‚¹å‡»ç‰¹æ•ˆ
        function triggerBuddhaClickEffect() {
            if (!buddha) return;

            // 1. å…‰ç¯é—ªçƒæ•ˆæœ
            buddha.children.forEach(child => {
                if (child.geometry instanceof THREE.RingGeometry) {
                    const originalEmissive = child.material.emissive.clone();
                    child.material.emissive.setHex(0xffd700);
                    
                    // æ¸å˜æ¢å¤åŸè‰²
                    let intensity = 1.0;
                    const fadeInterval = setInterval(() => {
                        intensity -= 0.05;
                        if (intensity <= 0) {
                            child.material.emissive.copy(originalEmissive);
                            clearInterval(fadeInterval);
                        } else {
                            child.material.emissive.setRGB(
                                originalEmissive.r + (1 - originalEmissive.r) * intensity,
                                originalEmissive.g + (0.84 - originalEmissive.g) * intensity,
                                originalEmissive.b + (0 - originalEmissive.b) * intensity
                            );
                        }
                    }, 50);
                }
            });

            // 2. ä½›åƒéœ‡åŠ¨æ•ˆæœ
            const originalPosition = buddha.position.clone();
            let shakeTime = 0;
            const shakeIntensity = 0.1;
            const shakeDuration = 500; // æ¯«ç§’
            
            const shakeInterval = setInterval(() => {
                shakeTime += 16; // çº¦60fps
                if (shakeTime >= shakeDuration) {
                    buddha.position.copy(originalPosition);
                    clearInterval(shakeInterval);
                } else {
                    const progress = shakeTime / shakeDuration;
                    const currentIntensity = shakeIntensity * (1 - progress);
                    buddha.position.x = originalPosition.x + (Math.random() - 0.5) * currentIntensity;
                    buddha.position.y = originalPosition.y + (Math.random() - 0.5) * currentIntensity;
                    buddha.position.z = originalPosition.z + (Math.random() - 0.5) * currentIntensity;
                }
            }, 16);

            // 3. åˆ›å»ºç‚¹å‡»ç²’å­çˆ†å‘æ•ˆæœ
            createClickParticles(buddha.position);

            // 4. ä¸´æ—¶å¢å¼ºä½›åƒèƒŒå…‰
            if (pointLights.length > 0) {
                const buddhaLight = pointLights[0]; // ä½›åƒèƒŒå…‰
                const originalIntensity = buddhaLight.intensity;
                buddhaLight.intensity = originalIntensity * 2;
                
                setTimeout(() => {
                    buddhaLight.intensity = originalIntensity;
                }, 1000);
            }

            console.log('ä½›åƒè¢«ç‚¹å‡»ï¼Œè§¦å‘ç‰¹æ®Šæ•ˆæœ');
        }

        // åˆ›å»ºç‚¹å‡»ç²’å­æ•ˆæœ
        function createClickParticles(position) {
            const particleCount = 20;
            const clickParticles = [];

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 1.0
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.position.y += 5; // ä»ä½›åƒå¤´éƒ¨ä½ç½®å¼€å§‹
                
                // éšæœºæ–¹å‘
                const direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2 + 1,
                    (Math.random() - 0.5) * 2
                ).normalize();
                
                particle.userData = {
                    velocity: direction.multiplyScalar(Math.random() * 5 + 2),
                    life: 1.0,
                    decay: 0.02
                };
                
                scene.add(particle);
                clickParticles.push(particle);
            }

            // åŠ¨ç”»ç²’å­
            const animateParticles = () => {
                for (let i = clickParticles.length - 1; i >= 0; i--) {
                    const particle = clickParticles[i];
                    const userData = particle.userData;
                    
                    // æ›´æ–°ä½ç½®
                    particle.position.add(userData.velocity);
                    userData.velocity.y -= 0.1; // é‡åŠ›
                    
                    // æ›´æ–°ç”Ÿå‘½å€¼å’Œé€æ˜åº¦
                    userData.life -= userData.decay;
                    particle.material.opacity = userData.life;
                    
                    // ç§»é™¤æ­»äº¡ç²’å­
                    if (userData.life <= 0) {
                        scene.remove(particle);
                        clickParticles.splice(i, 1);
                    }
                }
                
                if (clickParticles.length > 0) {
                    requestAnimationFrame(animateParticles);
                }
            };
            
            animateParticles();
        }

        // åˆ‡æ¢é¦™ç«
        function toggleIncense() {
            isIncenseOn = !isIncenseOn;
            document.getElementById('toggleIncense').classList.toggle('active', isIncenseOn);
            document.getElementById('incenseStatus').textContent = isIncenseOn ? 'ç‡ƒçƒ§ä¸­' : 'ç†„ç­';
            
            incenseSmoke.forEach(smoke => {
                smoke.visible = isIncenseOn;
            });
        }

        // åˆ‡æ¢è²èŠ±
        function toggleLotus() {
            isLotusOn = !isLotusOn;
            document.getElementById('toggleLotus').classList.toggle('active', isLotusOn);
            document.getElementById('lotusStatus').textContent = isLotusOn ? 'ç››å¼€' : 'å‡‹è°¢';
            
            lotusFlowers.forEach(lotus => {
                lotus.visible = isLotusOn;
            });
        }

        // åˆ‡æ¢ç²’å­æ•ˆæœ
        function toggleParticles() {
            isParticlesOn = !isParticlesOn;
            document.getElementById('toggleParticles').classList.toggle('active', isParticlesOn);
            
            particles.forEach(particle => {
                particle.visible = isParticlesOn;
            });
        }

        // åˆ‡æ¢éŸ³æ•ˆ
        function toggleSound() {
            isSoundOn = !isSoundOn;
            document.getElementById('toggleSound').classList.toggle('active', isSoundOn);
            document.getElementById('soundStatus').textContent = isSoundOn ? 'å¼€å¯' : 'å…³é—­';
            
            if (isSoundOn) {
                // å¼€å¯éŸ³æ•ˆ - æ’­æ”¾èƒŒæ™¯éŸ³ä¹
                if (backgroundMusic && isAudioInitialized) {
                    backgroundMusic.play().catch(error => {
                        console.error('æ’­æ”¾éŸ³ä¹å¤±è´¥:', error);
                    });
                }
            } else {
                // å…³é—­éŸ³æ•ˆ - æš‚åœèƒŒæ™¯éŸ³ä¹
                if (backgroundMusic) {
                    backgroundMusic.pause();
                }
            }
        }



        // åˆ‡æ¢å†¥æƒ³æ¨¡å¼
        function toggleMeditation() {
            isMeditating = !isMeditating;
            if (isMeditating) {
                meditationStartTime = Date.now();
            }
        }

        // é‡ç½®ç›¸æœº
        function resetCamera() {
            setCameraMode('free');
        }

        // åˆ‡æ¢å…¨å±
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // æ›´æ–°å†¥æƒ³è®¡æ—¶å™¨
        function updateMeditationTimer() {
            if (isMeditating) {
                const elapsed = Date.now() - meditationStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('meditationTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate(currentTime) {
            requestAnimationFrame(animate);

            // è®¡ç®—FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }

            // æ›´æ–°å†¥æƒ³è®¡æ—¶å™¨
            updateMeditationTimer();

            // ä½›åƒåŠ¨ç”»æ•ˆæœ
            if (buddha) {
                // å…‰ç¯æ—‹è½¬åŠ¨ç”» - å¤šå±‚å…‰ç¯ä¸åŒé€Ÿåº¦æ—‹è½¬
                buddha.children.forEach((child, index) => {
                    if (child.geometry instanceof THREE.RingGeometry) {
                        if (index === buddha.children.length - 1) {
                            // å¤–å±‚å…‰ç¯æ…¢é€Ÿæ—‹è½¬
                            child.rotation.z += 0.005;
                        } else if (index === buddha.children.length - 2) {
                            // å†…å±‚å…‰ç¯å¿«é€Ÿæ—‹è½¬
                            child.rotation.z -= 0.01;
                        } else if (index === buddha.children.length - 3) {
                            // ä¸»å…‰ç¯ä¸­é€Ÿæ—‹è½¬
                            child.rotation.z += 0.008;
                        }
                    }
                });

                // ä½›åƒæ•´ä½“è½»å¾®å‘¼å¸æ•ˆæœ
                const breathScale = 1 + Math.sin(currentTime * 0.002) * 0.015;
                buddha.scale.set(breathScale, breathScale, breathScale);

                // ä½›åƒå¤´éƒ¨è½»å¾®ç‚¹å¤´ - æ›´åº„ä¸¥çš„åŠ¨ä½œ
                const headNode = buddha.children.find(child => 
                    child.geometry instanceof THREE.SphereGeometry && child.position.y > 7
                );
                if (headNode) {
                    headNode.rotation.x = Math.sin(currentTime * 0.0008) * 0.03;
                }

                // å…‰ç¯è£…é¥°çƒä½“é—ªçƒ
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        child.material.color.getHex() === 0xffd700 && 
                        child.position.y > 8.5) {
                        child.material.opacity = 0.7 + Math.sin(currentTime * 0.01 + child.position.x) * 0.3;
                    }
                });

                // èƒ¸éƒ¨è£…é¥°å‘å…‰æ•ˆæœ - æ³•è½®å‘å…‰
                const chestOrnament = buddha.children.find(child => 
                    child.geometry instanceof THREE.CylinderGeometry && 
                    child.material.color.getHex() === 0xFF6347
                );
                if (chestOrnament) {
                    const glowIntensity = 0.8 + Math.sin(currentTime * 0.003) * 0.2;
                    chestOrnament.material.emissive.setRGB(glowIntensity * 0.3, 0, 0);
                }

                // è²èŠ±åº§èŠ±ç“£è½»å¾®æ‘†åŠ¨
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        (child.material.color.getHex() === 0xFF1493 || 
                         child.material.color.getHex() === 0xFF69B4 || 
                         child.material.color.getHex() === 0xFFB6C1)) {
                        const originalY = child.userData.originalY || child.position.y;
                        child.userData.originalY = originalY;
                        child.position.y = originalY + Math.sin(currentTime * 0.004 + child.position.x) * 0.05;
                        child.rotation.z = Math.sin(currentTime * 0.003 + child.position.z) * 0.05;
                    }
                });

                // æ‰“åæ‰‹å°è½»å¾®æ‘†åŠ¨ - ç¦…å®šçŠ¶æ€çš„å¾®åŠ¨
                buddha.children.forEach(child => {
                    // æ‰‹éƒ¨åŠ¨ç”»
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        Math.abs(child.position.x) < 0.5 && 
                        child.position.y > 3 && child.position.y < 4) {
                        const side = child.position.x > 0 ? 1 : -1;
                        const originalY = child.userData.originalY || child.position.y;
                        child.userData.originalY = originalY;
                        child.position.y = originalY + Math.sin(currentTime * 0.001 + side) * 0.02;
                    }
                    
                    // æ‰‹è‡‚è½»å¾®å‘¼å¸æ‘†åŠ¨
                    if (child.geometry instanceof THREE.CylinderGeometry && 
                        Math.abs(child.position.x) > 1.5 && child.position.y > 4) {
                        const side = child.position.x > 0 ? 1 : -1;
                        child.rotation.z = side * (Math.PI / 8 + Math.sin(currentTime * 0.0015) * 0.02);
                    }
                });

                // ç›˜è…¿åå§¿çš„è…¿éƒ¨è½»å¾®è°ƒæ•´
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.CylinderGeometry && 
                        child.position.y < 3.5 && Math.abs(child.position.x) > 1) {
                        const side = child.position.x > 0 ? 1 : -1;
                        const originalRotationZ = child.userData.originalRotationZ || child.rotation.z;
                        child.userData.originalRotationZ = originalRotationZ;
                        child.rotation.z = originalRotationZ + Math.sin(currentTime * 0.001) * 0.01 * side;
                    }
                });

                // è„šéƒ¨è½»å¾®æ‘†åŠ¨
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        child.position.y < 2.5 && Math.abs(child.position.x) > 2) {
                        const originalY = child.userData.originalY || child.position.y;
                        child.userData.originalY = originalY;
                        child.position.y = originalY + Math.sin(currentTime * 0.002 + child.position.x) * 0.01;
                    }
                });

                // æ‰‹æŒ‡ç»†èŠ‚åŠ¨ç”» - ç¦…å®šå°çš„å¾®åŠ¨
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.CylinderGeometry && 
                        child.geometry.parameters && 
                        child.geometry.parameters.radiusTop < 0.1) {
                        const originalRotationX = child.userData.originalRotationX || child.rotation.x;
                        child.userData.originalRotationX = originalRotationX;
                        child.rotation.x = originalRotationX + Math.sin(currentTime * 0.003 + child.position.x * 10) * 0.02;
                    }
                });
            }

            // è²èŠ±æµ®åŠ¨åŠ¨ç”»
            lotusFlowers.forEach((lotus, index) => {
                if (lotus.visible) {
                    lotus.position.y = 0.5 + Math.sin(currentTime * 0.001 + index) * 0.1;
                    lotus.rotation.y += 0.005;
                }
            });

            // ç²’å­åŠ¨ç”»
            particles.forEach(particle => {
                if (particle.visible) {
                    const positions = particle.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += 0.02; // å‘ä¸Šé£˜åŠ¨
                        if (positions[i] > 20) {
                            positions[i] = 0; // é‡ç½®åˆ°åº•éƒ¨
                        }
                    }
                    particle.geometry.attributes.position.needsUpdate = true;
                    particle.rotation.y += 0.002;
                }
            });

            // é¦™çƒŸåŠ¨ç”»
            if (isIncenseOn) {
                incenseSmoke.forEach(smoke => {
                    const positions = smoke.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += 0.05; // å‘ä¸Šé£˜åŠ¨
                        if (positions[i] > 20) {
                            positions[i] = 7.25; // é‡ç½®åˆ°é¦™çš„é¡¶ç«¯
                        }
                    }
                    smoke.geometry.attributes.position.needsUpdate = true;
                });
            }

            // èœ¡çƒ›å…‰æºé—ªçƒ
            pointLights.forEach((light, index) => {
                if (index > 0) { // è·³è¿‡ä½›åƒèƒŒå…‰
                    light.intensity = 0.5 + Math.sin(currentTime * 0.01 + index) * 0.1;
                }
            });

            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>