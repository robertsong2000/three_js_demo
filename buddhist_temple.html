<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🏛️ Three.js 中式佛堂3D模型</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #2c1810 0%, #8B4513 50%, #DAA520 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #DAA520;
            backdrop-filter: blur(10px);
            min-width: 280px;
        }

        #info h1 {
            color: #DAA520;
            margin-bottom: 10px;
            font-size: 18px;
            text-shadow: 0 0 10px #DAA520;
            text-align: center;
        }

        .info-item {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            color: #DAA520;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #DAA520;
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin: 10px 0;
        }

        .control-group label {
            display: block;
            color: #DAA520;
            margin-bottom: 5px;
            font-size: 12px;
            font-weight: bold;
        }

        button {
            background: linear-gradient(45deg, #DAA520, #FFD700);
            border: none;
            color: #8B4513;
            padding: 8px 15px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(218, 165, 32, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(45deg, #FF6347, #FF4500);
            color: white;
            box-shadow: 0 0 20px rgba(255, 99, 71, 0.5);
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #DAA520;
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        #instructions h3 {
            color: #DAA520;
            margin-bottom: 10px;
            font-size: 14px;
            text-align: center;
        }

        #instructions ul {
            list-style: none;
            font-size: 11px;
            line-height: 1.4;
        }

        #instructions li {
            margin: 3px 0;
            color: #ccc;
        }

        #instructions .key {
            color: #DAA520;
            font-weight: bold;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            color: #DAA520;
            font-size: 18px;
        }

        .loading.hidden {
            display: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .float {
            animation: float 3s ease-in-out infinite;
        }

        #meditation-timer {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 50%;
            border: 3px solid #DAA520;
            width: 120px;
            height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        #meditation-timer .time {
            font-size: 16px;
            font-weight: bold;
            color: #DAA520;
        }

        #meditation-timer .label {
            font-size: 10px;
            color: #aaa;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="loading">
            <div class="pulse">🏛️ 正在构建中式佛堂...</div>
            <div style="font-size: 12px; margin-top: 10px; color: #aaa;">
                南无阿弥陀佛 🙏
            </div>
        </div>

        <div id="info">
            <h1>🏛️ 中式佛堂</h1>
            <div class="info-item">
                <span class="info-label">视角模式:</span>
                <span class="info-value" id="cameraMode">自由视角</span>
            </div>
            <div class="info-item">
                <span class="info-label">香火状态:</span>
                <span class="info-value" id="incenseStatus">燃烧中</span>
            </div>
            <div class="info-item">
                <span class="info-label">灯光模式:</span>
                <span class="info-value" id="lightMode">温暖</span>
            </div>
            <div class="info-item">
                <span class="info-label">音效:</span>
                <span class="info-value" id="soundStatus">开启</span>
            </div>
            <div class="info-item">
                <span class="info-label">莲花状态:</span>
                <span class="info-value" id="lotusStatus">盛开</span>
            </div>
            <div class="info-item">
                <span class="info-label">FPS:</span>
                <span class="info-value" id="fps">60</span>
            </div>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>🎥 视角控制</label>
                <button id="cameraFree" class="active">自由视角</button>
                <button id="cameraFront">正面视角</button>
                <button id="cameraSide">侧面视角</button>
                <button id="cameraTop">俯视视角</button>
            </div>

            <div class="control-group">
                <label>💡 灯光氛围</label>
                <button id="lightWarm" class="active">温暖</button>
                <button id="lightCool">清冷</button>
                <button id="lightGolden">金辉</button>
                <button id="lightCandle">烛光</button>
            </div>

            <div class="control-group">
                <label>🌸 场景元素</label>
                <button id="toggleIncense" class="active">香火</button>
                <button id="toggleLotus" class="active">莲花</button>
                <button id="toggleParticles" class="active">光粒</button>
                <button id="toggleSound" class="active">音效</button>
            </div>

            <div class="control-group">
                <label>🎵 背景音乐音量: <span id="volumeValue">50%</span></label>
                <input type="range" id="musicVolume" min="0" max="100" value="50">
            </div>
        </div>

        <div id="instructions">
            <h3>🙏 操作指南</h3>
            <ul>
                <li><span class="key">鼠标拖拽</span> - 旋转视角</li>
                <li><span class="key">滚轮</span> - 缩放视角</li>
                <li><span class="key">空格</span> - 开始/停止冥想</li>
                <li><span class="key">R</span> - 重置视角</li>
                <li><span class="key">1-4</span> - 快速切换视角</li>
                <li><span class="key">I</span> - 切换香火</li>
                <li><span class="key">L</span> - 切换莲花</li>
                <li><span class="key">P</span> - 切换光粒效果</li>
                <li><span class="key">M</span> - 静音/取消静音</li>
                <li><span class="key">F</span> - 全屏模式</li>
            </ul>
        </div>

        <div id="meditation-timer">
            <div class="time" id="meditationTime">00:00</div>
            <div class="label">冥想时间</div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
        // 全局变量
        let scene, camera, renderer, controls;
        let currentCameraMode = 'free';
        let currentLightMode = 'warm';
        let isIncenseOn = true;
        let isLotusOn = true;
        let isParticlesOn = true;
        let isSoundOn = true;
        let isMeditating = false;
        let meditationStartTime = 0;
        let frameCount = 0;
        let lastTime = 0;
        let fps = 60;

        // 场景对象
        let buddha, altar, incenseSticks = [], lotusFlowers = [];
        let particles = [], incenseSmoke = [];
        let ambientLight, mainLight, pointLights = [];
        let mouseX = 0, mouseY = 0;

        // 音频对象
        let backgroundMusic;
        let isAudioInitialized = false;

        // 初始化
        function init() {
            // 创建场景
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x2c1810, 50, 200);

            // 创建相机
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 15, 30);

            // 创建渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setClearColor(0x2c1810);
            document.getElementById('container').appendChild(renderer.domElement);

            // 初始化音频
            initAudio();

            // 设置光照
            setupLighting();

            // 创建佛堂场景
            createTempleScene();

            // 设置控制器
            setupControls();

            // 设置事件监听
            setupEventListeners();

            // 隐藏加载界面
            document.getElementById('loading').classList.add('hidden');

            // 开始渲染循环
            animate();
        }

        // 设置光照
        function setupLighting() {
            // 环境光
            ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            // 主光源
            mainLight = new THREE.DirectionalLight(0xffd700, 0.8);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024;
            mainLight.shadow.mapSize.height = 1024;
            scene.add(mainLight);

            // 佛像背光
            const buddhaLight = new THREE.PointLight(0xffd700, 1, 50);
            buddhaLight.position.set(0, 15, -5);
            scene.add(buddhaLight);
            pointLights.push(buddhaLight);

            // 蜡烛光源
            for (let i = 0; i < 4; i++) {
                const candleLight = new THREE.PointLight(0xff6600, 0.5, 20);
                const angle = (i / 4) * Math.PI * 2;
                candleLight.position.set(Math.cos(angle) * 8, 3, Math.sin(angle) * 8);
                scene.add(candleLight);
                pointLights.push(candleLight);
            }
        }

        // 初始化音频系统
        function initAudio() {
            try {
                // 创建音频元素
                backgroundMusic = new Audio('180469__soniaespi__echo-in-a-buddhist-temple.wav');
                backgroundMusic.loop = true;
                backgroundMusic.volume = 0.5;
                backgroundMusic.preload = 'auto';
                
                console.log('音频文件加载成功');
                isAudioInitialized = true;
                
                // 添加音频事件监听
                backgroundMusic.addEventListener('canplaythrough', () => {
                    console.log('音频可以播放');
                });
                
                backgroundMusic.addEventListener('error', (e) => {
                    console.error('音频加载错误:', e);
                });
                
                // 添加测试按钮
                addAudioTestButton();
            } catch (error) {
                console.warn('音频初始化失败:', error);
                isAudioInitialized = false;
            }
        }

        // 添加音频测试按钮
        function addAudioTestButton() {
            const testButton = document.createElement('button');
            testButton.textContent = '播放音乐';
            testButton.style.position = 'fixed';
            testButton.style.top = '10px';
            testButton.style.right = '10px';
            testButton.style.zIndex = '1000';
            testButton.style.padding = '10px';
            testButton.style.backgroundColor = '#4CAF50';
            testButton.style.color = 'white';
            testButton.style.border = 'none';
            testButton.style.borderRadius = '5px';
            testButton.style.cursor = 'pointer';
            
            testButton.addEventListener('click', async () => {
                if (backgroundMusic.paused) {
                    try {
                        await backgroundMusic.play();
                        testButton.textContent = '暂停音乐';
                        testButton.style.backgroundColor = '#f44336';
                        console.log('开始播放佛教音乐');
                    } catch (error) {
                        console.error('播放失败:', error);
                    }
                } else {
                    backgroundMusic.pause();
                    testButton.textContent = '播放音乐';
                    testButton.style.backgroundColor = '#4CAF50';
                    console.log('暂停佛教音乐');
                }
            });
            
            document.body.appendChild(testButton);
        }

        // 设置音乐音量
        function setMusicVolume(volume) {
            if (backgroundMusic) {
                backgroundMusic.volume = volume / 100;
            }
        }

        // 创建佛堂场景
        function createTempleScene() {
            // 创建地面
            createFloor();

            // 创建墙壁
            createWalls();

            // 创建佛台
            createAltar();

            // 创建佛像
            createBuddha();

            // 创建香炉和香
            createIncense();

            // 创建莲花
            createLotusFlowers();

            // 创建蒲团
            createCushions();

            // 创建装饰品
            createDecorations();

            // 创建粒子效果
            createParticleEffects();
        }

        // 创建地面
        function createFloor() {
            const floorGeometry = new THREE.PlaneGeometry(60, 60);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x8B4513,
                transparent: true,
                opacity: 0.9
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            // 地面花纹
            const patternGeometry = new THREE.RingGeometry(5, 15, 8);
            const patternMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xDAA520,
                transparent: true,
                opacity: 0.3
            });
            const pattern = new THREE.Mesh(patternGeometry, patternMaterial);
            pattern.rotation.x = -Math.PI / 2;
            pattern.position.y = 0.01;
            scene.add(pattern);
        }

        // 创建墙壁
        function createWalls() {
            const wallHeight = 20;
            const wallWidth = 60;

            // 后墙
            const backWallGeometry = new THREE.PlaneGeometry(wallWidth, wallHeight);
            const wallMaterial = new THREE.MeshLambertMaterial({ color: 0x8B4513 });
            const backWall = new THREE.Mesh(backWallGeometry, wallMaterial);
            backWall.position.set(0, wallHeight/2, -30);
            backWall.receiveShadow = true;
            scene.add(backWall);

            // 侧墙
            const sideWallGeometry = new THREE.PlaneGeometry(wallWidth, wallHeight);
            const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            leftWall.position.set(-30, wallHeight/2, 0);
            leftWall.rotation.y = Math.PI / 2;
            leftWall.receiveShadow = true;
            scene.add(leftWall);

            const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
            rightWall.position.set(30, wallHeight/2, 0);
            rightWall.rotation.y = -Math.PI / 2;
            rightWall.receiveShadow = true;
            scene.add(rightWall);

            // 墙上装饰
            createWallDecorations();
        }

        // 创建墙面装饰
        function createWallDecorations() {
            // 佛教符号
            const symbolGeometry = new THREE.CircleGeometry(2, 8);
            const symbolMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xDAA520,
                transparent: true,
                opacity: 0.8
            });

            for (let i = 0; i < 3; i++) {
                const symbol = new THREE.Mesh(symbolGeometry, symbolMaterial);
                symbol.position.set((i - 1) * 8, 12, -29.9);
                scene.add(symbol);
            }
        }

        // 创建佛台
        function createAltar() {
            altar = new THREE.Group();

            // 佛台底座
            const baseGeometry = new THREE.BoxGeometry(16, 2, 8);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 1;
            base.castShadow = true;
            base.receiveShadow = true;
            altar.add(base);

            // 佛台台面
            const topGeometry = new THREE.BoxGeometry(18, 0.5, 10);
            const topMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
            const top = new THREE.Mesh(topGeometry, topMaterial);
            top.position.y = 2.25;
            top.castShadow = true;
            top.receiveShadow = true;
            altar.add(top);

            altar.position.set(0, 0, -15);
            scene.add(altar);
        }

        // 创建佛像
        function createBuddha() {
            buddha = new THREE.Group();

            // 创建精细的莲花座
            createDetailedLotusBase();

            // 创建盘腿坐姿的腿部
            createBuddhaLegs();

            // 佛像身体 - 端正挺直的躯干
            const bodyGeometry = new THREE.CylinderGeometry(1.4, 1.6, 4.5, 16);
            const bodyMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150,
                specular: 0x444444
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            body.position.y = 4.5;
            body.castShadow = true;
            buddha.add(body);

            // 佛像肩膀 - 宽阔的肩膀
            const shoulderGeometry = new THREE.CylinderGeometry(1.8, 1.4, 1, 16);
            const shoulder = new THREE.Mesh(shoulderGeometry, bodyMaterial);
            shoulder.position.y = 6.2;
            shoulder.castShadow = true;
            buddha.add(shoulder);

            // 佛像胸部装饰 - 庄严的法轮
            const chestOrnamentGeometry = new THREE.CylinderGeometry(0.3, 0.3, 0.1, 8);
            const chestOrnamentMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFF6347,
                shininess: 200,
                emissive: 0x220000
            });
            const chestOrnament = new THREE.Mesh(chestOrnamentGeometry, chestOrnamentMaterial);
            chestOrnament.position.set(0, 5.8, 1.3);
            buddha.add(chestOrnament);

            // 佛像头部 - 更精细
            const headGeometry = new THREE.SphereGeometry(1.2, 20, 20);
            const headMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150,
                specular: 0x333333
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 7.8;
            head.castShadow = true;
            buddha.add(head);

            // 佛像面部特征
            createBuddhaFace();

            // 佛像手臂 - 打坐手印
            createMeditationArms();

            // 佛像服饰褶皱
            createBuddhaRobes();

            // 增强版光环
            createEnhancedHalo();

            // 头顶肉髻
            const topKnotGeometry = new THREE.SphereGeometry(0.4, 12, 12);
            const topKnotMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xB8860B,
                shininess: 100
            });
            const topKnot = new THREE.Mesh(topKnotGeometry, topKnotMaterial);
            topKnot.position.set(0, 8.8, 0);
            topKnot.castShadow = true;
            buddha.add(topKnot);

            buddha.position.set(0, 2.5, -15);
            scene.add(buddha);
        }

        // 创建盘腿坐姿
        function createBuddhaLegs() {
            const legMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });

            // 左腿 - 盘腿姿势
            const leftThighGeometry = new THREE.CylinderGeometry(0.6, 0.8, 2.5, 12);
            const leftThigh = new THREE.Mesh(leftThighGeometry, legMaterial);
            leftThigh.position.set(-1.2, 2.8, 0.5);
            leftThigh.rotation.z = Math.PI / 6;
            leftThigh.rotation.x = Math.PI / 3;
            leftThigh.castShadow = true;
            buddha.add(leftThigh);

            const leftCalfGeometry = new THREE.CylinderGeometry(0.5, 0.6, 2, 12);
            const leftCalf = new THREE.Mesh(leftCalfGeometry, legMaterial);
            leftCalf.position.set(-2, 2, 1.8);
            leftCalf.rotation.z = Math.PI / 4;
            leftCalf.rotation.x = Math.PI / 2;
            leftCalf.castShadow = true;
            buddha.add(leftCalf);

            // 右腿 - 盘腿姿势
            const rightThigh = new THREE.Mesh(leftThighGeometry, legMaterial);
            rightThigh.position.set(1.2, 2.8, 0.5);
            rightThigh.rotation.z = -Math.PI / 6;
            rightThigh.rotation.x = Math.PI / 3;
            rightThigh.castShadow = true;
            buddha.add(rightThigh);

            const rightCalf = new THREE.Mesh(leftCalfGeometry, legMaterial);
            rightCalf.position.set(2, 2, 1.8);
            rightCalf.rotation.z = -Math.PI / 4;
            rightCalf.rotation.x = Math.PI / 2;
            rightCalf.castShadow = true;
            buddha.add(rightCalf);

            // 脚部
            const footGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const leftFoot = new THREE.Mesh(footGeometry, legMaterial);
            leftFoot.position.set(-2.8, 1.8, 2.2);
            leftFoot.scale.set(1.2, 0.6, 1.5);
            leftFoot.castShadow = true;
            buddha.add(leftFoot);

            const rightFoot = new THREE.Mesh(footGeometry, legMaterial);
            rightFoot.position.set(2.8, 1.8, 2.2);
            rightFoot.scale.set(1.2, 0.6, 1.5);
            rightFoot.castShadow = true;
            buddha.add(rightFoot);
        }

        // 创建禅定手印的手臂
        function createMeditationArms() {
            const armMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });

            // 左臂 - 自然下垂
            const leftUpperArmGeometry = new THREE.CylinderGeometry(0.4, 0.5, 2.5, 8);
            const leftUpperArm = new THREE.Mesh(leftUpperArmGeometry, armMaterial);
            leftUpperArm.position.set(-1.8, 5.5, 0);
            leftUpperArm.rotation.z = Math.PI / 8;
            leftUpperArm.castShadow = true;
            buddha.add(leftUpperArm);

            const leftForearmGeometry = new THREE.CylinderGeometry(0.3, 0.4, 2, 8);
            const leftForearm = new THREE.Mesh(leftForearmGeometry, armMaterial);
            leftForearm.position.set(-1.2, 3.8, 1.2);
            leftForearm.rotation.z = Math.PI / 6;
            leftForearm.rotation.x = -Math.PI / 4;
            leftForearm.castShadow = true;
            buddha.add(leftForearm);

            // 右臂 - 自然下垂
            const rightUpperArm = new THREE.Mesh(leftUpperArmGeometry, armMaterial);
            rightUpperArm.position.set(1.8, 5.5, 0);
            rightUpperArm.rotation.z = -Math.PI / 8;
            rightUpperArm.castShadow = true;
            buddha.add(rightUpperArm);

            const rightForearm = new THREE.Mesh(leftForearmGeometry, armMaterial);
            rightForearm.position.set(1.2, 3.8, 1.2);
            rightForearm.rotation.z = -Math.PI / 6;
            rightForearm.rotation.x = -Math.PI / 4;
            rightForearm.castShadow = true;
            buddha.add(rightForearm);

            // 禅定手印 - 双手合十于腹前
            const handGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const handMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });

            // 左手
            const leftHand = new THREE.Mesh(handGeometry, handMaterial);
            leftHand.position.set(-0.3, 3.2, 2);
            leftHand.scale.set(0.8, 1.2, 0.6);
            leftHand.rotation.y = Math.PI / 6;
            leftHand.castShadow = true;
            buddha.add(leftHand);

            // 右手
            const rightHand = new THREE.Mesh(handGeometry, handMaterial);
            rightHand.position.set(0.3, 3.2, 2);
            rightHand.scale.set(0.8, 1.2, 0.6);
            rightHand.rotation.y = -Math.PI / 6;
            rightHand.castShadow = true;
            buddha.add(rightHand);

            // 手指细节 - 禅定印
            for (let i = 0; i < 5; i++) {
                const fingerGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 6);
                const fingerMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
                
                // 左手手指
                const leftFinger = new THREE.Mesh(fingerGeometry, fingerMaterial);
                leftFinger.position.set(-0.3 + (i - 2) * 0.1, 3.8, 2.2);
                leftFinger.rotation.x = Math.PI / 12;
                buddha.add(leftFinger);

                // 右手手指
                const rightFinger = new THREE.Mesh(fingerGeometry, fingerMaterial);
                rightFinger.position.set(0.3 + (i - 2) * 0.1, 3.8, 2.2);
                rightFinger.rotation.x = Math.PI / 12;
                buddha.add(rightFinger);
            }

            buddha.position.set(0, 2.5, -15);
            scene.add(buddha);
        }

        // 创建精细的莲花座
        function createDetailedLotusBase() {
            // 莲花座底座
            const baseGeometry = new THREE.CylinderGeometry(3.5, 4, 1.5, 16);
            const baseMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x228B22,
                shininess: 80
            });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.y = 0.75;
            base.castShadow = true;
            buddha.add(base);

            // 多层莲花花瓣
            for (let layer = 0; layer < 3; layer++) {
                const petalCount = 8 + layer * 4;
                const radius = 2.5 + layer * 0.5;
                const height = 1.5 + layer * 0.3;
                
                for (let i = 0; i < petalCount; i++) {
                    const petalGeometry = new THREE.SphereGeometry(0.6, 8, 8);
                    const petalMaterial = new THREE.MeshPhongMaterial({ 
                        color: layer === 0 ? 0xFF1493 : layer === 1 ? 0xFF69B4 : 0xFFB6C1,
                        transparent: true,
                        opacity: 0.9,
                        shininess: 100
                    });
                    const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                    const angle = (i / petalCount) * Math.PI * 2 + layer * 0.2;
                    petal.position.set(
                        Math.cos(angle) * radius, 
                        height, 
                        Math.sin(angle) * radius
                    );
                    petal.scale.set(0.8, 0.4, 1.2);
                    petal.rotation.y = angle;
                    petal.rotation.x = -0.3;
                    petal.castShadow = true;
                    buddha.add(petal);
                }
            }

            // 莲花中心
            const centerGeometry = new THREE.SphereGeometry(0.5, 12, 12);
            const centerMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xFFD700,
                transparent: true,
                opacity: 0.8
            });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 2;
            buddha.add(center);
        }

        // 创建佛像面部特征
        function createBuddhaFace() {
            // 眼睛
            const eyeGeometry = new THREE.SphereGeometry(0.1, 8, 8);
            const eyeMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
            
            const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            leftEye.position.set(-0.3, 8.7, 1.1);
            buddha.add(leftEye);
            
            const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
            rightEye.position.set(0.3, 8.7, 1.1);
            buddha.add(rightEye);

            // 眉毛
            const eyebrowGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.4, 6);
            const eyebrowMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            
            const leftEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            leftEyebrow.position.set(-0.3, 9, 1.1);
            leftEyebrow.rotation.z = Math.PI / 2;
            buddha.add(leftEyebrow);
            
            const rightEyebrow = new THREE.Mesh(eyebrowGeometry, eyebrowMaterial);
            rightEyebrow.position.set(0.3, 9, 1.1);
            rightEyebrow.rotation.z = Math.PI / 2;
            buddha.add(rightEyebrow);

            // 鼻子
            const noseGeometry = new THREE.ConeGeometry(0.1, 0.3, 6);
            const noseMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
            const nose = new THREE.Mesh(noseGeometry, noseMaterial);
            nose.position.set(0, 8.3, 1.2);
            nose.rotation.x = Math.PI;
            buddha.add(nose);

            // 嘴唇 - 微笑
            const mouthGeometry = new THREE.TorusGeometry(0.2, 0.05, 4, 8, Math.PI);
            const mouthMaterial = new THREE.MeshPhongMaterial({ color: 0xB8860B });
            const mouth = new THREE.Mesh(mouthGeometry, mouthMaterial);
            mouth.position.set(0, 7.9, 1.1);
            mouth.rotation.x = Math.PI;
            buddha.add(mouth);
        }

        // 创建佛像手臂
        function createBuddhaArms() {
            // 左臂
            const leftArmGeometry = new THREE.CylinderGeometry(0.4, 0.5, 3, 8);
            const armMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });
            const leftArm = new THREE.Mesh(leftArmGeometry, armMaterial);
            leftArm.position.set(-2.2, 6, 0);
            leftArm.rotation.z = Math.PI / 6;
            leftArm.castShadow = true;
            buddha.add(leftArm);

            // 右臂
            const rightArm = new THREE.Mesh(leftArmGeometry, armMaterial);
            rightArm.position.set(2.2, 6, 0);
            rightArm.rotation.z = -Math.PI / 6;
            rightArm.castShadow = true;
            buddha.add(rightArm);

            // 左手 - 施无畏印
            const leftHandGeometry = new THREE.SphereGeometry(0.5, 8, 8);
            const handMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xDAA520,
                shininess: 150
            });
            const leftHand = new THREE.Mesh(leftHandGeometry, handMaterial);
            leftHand.position.set(-3, 4.5, 1);
            leftHand.castShadow = true;
            buddha.add(leftHand);

            // 右手 - 与愿印
            const rightHand = new THREE.Mesh(leftHandGeometry, handMaterial);
            rightHand.position.set(3, 4.5, 1);
            rightHand.castShadow = true;
            buddha.add(rightHand);

            // 手指细节
            for (let hand = 0; hand < 2; hand++) {
                const handX = hand === 0 ? -3 : 3;
                for (let finger = 0; finger < 5; finger++) {
                    const fingerGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.6, 6);
                    const fingerMaterial = new THREE.MeshPhongMaterial({ color: 0xDAA520 });
                    const fingerMesh = new THREE.Mesh(fingerGeometry, fingerMaterial);
                    fingerMesh.position.set(
                        handX + (finger - 2) * 0.15,
                        4.8,
                        1.3
                    );
                    fingerMesh.castShadow = true;
                    buddha.add(fingerMesh);
                }
            }
        }

        // 创建佛像服饰褶皱
        function createBuddhaRobes() {
            // 袈裟褶皱
            for (let i = 0; i < 6; i++) {
                const foldGeometry = new THREE.CylinderGeometry(0.1, 0.1, 4, 6);
                const foldMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xB8860B,
                    transparent: true,
                    opacity: 0.8
                });
                const fold = new THREE.Mesh(foldGeometry, foldMaterial);
                const angle = (i / 6) * Math.PI * 2;
                fold.position.set(
                    Math.cos(angle) * 1.5,
                    5,
                    Math.sin(angle) * 1.5
                );
                fold.rotation.x = Math.PI / 2;
                fold.rotation.y = angle;
                buddha.add(fold);
            }

            // 腰带
            const beltGeometry = new THREE.TorusGeometry(2, 0.2, 8, 16);
            const beltMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8B0000,
                shininess: 100
            });
            const belt = new THREE.Mesh(beltGeometry, beltMaterial);
            belt.position.y = 4;
            belt.rotation.x = Math.PI / 2;
            buddha.add(belt);
        }

        // 创建增强版光环
        function createEnhancedHalo() {
            // 主光环
            const haloGeometry = new THREE.RingGeometry(2.5, 3.5, 32);
            const haloMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const halo = new THREE.Mesh(haloGeometry, haloMaterial);
            halo.position.set(0, 9, -1);
            buddha.add(halo);

            // 内层光环
            const innerHaloGeometry = new THREE.RingGeometry(1.8, 2.3, 24);
            const innerHaloMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                transparent: true,
                opacity: 0.6,
                side: THREE.DoubleSide
            });
            const innerHalo = new THREE.Mesh(innerHaloGeometry, innerHaloMaterial);
            innerHalo.position.set(0, 9, -0.8);
            buddha.add(innerHalo);

            // 光环装饰
            for (let i = 0; i < 12; i++) {
                const ornamentGeometry = new THREE.SphereGeometry(0.1, 6, 6);
                const ornamentMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xffd700,
                    transparent: true,
                    opacity: 0.9
                });
                const ornament = new THREE.Mesh(ornamentGeometry, ornamentMaterial);
                const angle = (i / 12) * Math.PI * 2;
                ornament.position.set(
                    Math.cos(angle) * 3,
                    9,
                    Math.sin(angle) * 3 - 1
                );
                buddha.add(ornament);
            }

            // 光环发光效果
            const glowGeometry = new THREE.RingGeometry(3.5, 4.5, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffd700,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.set(0, 9, -1.2);
            buddha.add(glow);
        }

        // 创建香炉和香
        function createIncense() {
            // 香炉
            const incenseHolderGeometry = new THREE.CylinderGeometry(2, 2.5, 1.5, 8);
            const incenseHolderMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const incenseHolder = new THREE.Mesh(incenseHolderGeometry, incenseHolderMaterial);
            incenseHolder.position.set(0, 3.25, -10);
            incenseHolder.castShadow = true;
            scene.add(incenseHolder);

            // 香
            for (let i = 0; i < 5; i++) {
                const stickGeometry = new THREE.CylinderGeometry(0.05, 0.05, 4, 8);
                const stickMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513 });
                const stick = new THREE.Mesh(stickGeometry, stickMaterial);
                stick.position.set((i - 2) * 0.3, 5.25, -10);
                stick.castShadow = true;
                scene.add(stick);
                incenseSticks.push(stick);

                // 香火顶端
                const fireGeometry = new THREE.SphereGeometry(0.1, 8, 8);
                const fireMaterial = new THREE.MeshBasicMaterial({ 
                    color: 0xff4500,
                    transparent: true,
                    opacity: 0.8
                });
                const fire = new THREE.Mesh(fireGeometry, fireMaterial);
                fire.position.set((i - 2) * 0.3, 7.25, -10);
                scene.add(fire);
            }

            // 创建香烟效果
            createIncenseSmoke();
        }

        // 创建香烟效果
        function createIncenseSmoke() {
            for (let i = 0; i < 5; i++) {
                const smokeGeometry = new THREE.BufferGeometry();
                const smokeMaterial = new THREE.PointsMaterial({
                    color: 0xcccccc,
                    size: 0.5,
                    transparent: true,
                    opacity: 0.3
                });

                const smokeVertices = [];
                for (let j = 0; j < 20; j++) {
                    smokeVertices.push(
                        (i - 2) * 0.3 + (Math.random() - 0.5) * 0.5,
                        7.25 + j * 0.5,
                        -10 + (Math.random() - 0.5) * 0.5
                    );
                }

                smokeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(smokeVertices, 3));
                const smoke = new THREE.Points(smokeGeometry, smokeMaterial);
                scene.add(smoke);
                incenseSmoke.push(smoke);
            }
        }

        // 创建莲花
        function createLotusFlowers() {
            const positions = [
                { x: -8, z: -5 },
                { x: 8, z: -5 },
                { x: -12, z: 5 },
                { x: 12, z: 5 },
                { x: 0, z: 10 }
            ];

            positions.forEach((pos, index) => {
                const lotus = createSingleLotus();
                lotus.position.set(pos.x, 0.5, pos.z);
                scene.add(lotus);
                lotusFlowers.push(lotus);
            });
        }

        // 创建单朵莲花
        function createSingleLotus() {
            const lotus = new THREE.Group();

            // 莲花底座
            const baseGeometry = new THREE.CylinderGeometry(1.5, 1.5, 0.3, 8);
            const baseMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.castShadow = true;
            lotus.add(base);

            // 莲花花瓣
            for (let i = 0; i < 8; i++) {
                const petalGeometry = new THREE.SphereGeometry(0.8, 8, 8);
                const petalMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xFF69B4,
                    transparent: true,
                    opacity: 0.8
                });
                const petal = new THREE.Mesh(petalGeometry, petalMaterial);
                const angle = (i / 8) * Math.PI * 2;
                petal.position.set(Math.cos(angle) * 0.8, 0.5, Math.sin(angle) * 0.8);
                petal.scale.set(0.5, 0.3, 1);
                petal.castShadow = true;
                lotus.add(petal);
            }

            // 莲花中心
            const centerGeometry = new THREE.SphereGeometry(0.3, 8, 8);
            const centerMaterial = new THREE.MeshBasicMaterial({ color: 0xFFD700 });
            const center = new THREE.Mesh(centerGeometry, centerMaterial);
            center.position.y = 0.5;
            lotus.add(center);

            return lotus;
        }

        // 创建蒲团
        function createCushions() {
            const positions = [
                { x: -6, z: 8 },
                { x: 0, z: 12 },
                { x: 6, z: 8 }
            ];

            positions.forEach(pos => {
                const cushionGeometry = new THREE.CylinderGeometry(2, 2, 0.5, 16);
                const cushionMaterial = new THREE.MeshPhongMaterial({ color: 0x8B0000 });
                const cushion = new THREE.Mesh(cushionGeometry, cushionMaterial);
                cushion.position.set(pos.x, 0.25, pos.z);
                cushion.castShadow = true;
                cushion.receiveShadow = true;
                scene.add(cushion);
            });
        }

        // 创建装饰品
        function createDecorations() {
            // 花瓶
            const vasePositions = [
                { x: -6, z: -12 },
                { x: 6, z: -12 }
            ];

            vasePositions.forEach(pos => {
                const vaseGeometry = new THREE.CylinderGeometry(1, 1.5, 4, 8);
                const vaseMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
                const vase = new THREE.Mesh(vaseGeometry, vaseMaterial);
                vase.position.set(pos.x, 4.5, pos.z);
                vase.castShadow = true;
                scene.add(vase);
            });

            // 经书
            const bookGeometry = new THREE.BoxGeometry(2, 0.3, 3);
            const bookMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const book = new THREE.Mesh(bookGeometry, bookMaterial);
            book.position.set(-4, 2.75, -10);
            book.castShadow = true;
            scene.add(book);

            // 木鱼
            const woodenFishGeometry = new THREE.SphereGeometry(1, 8, 8);
            const woodenFishMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
            const woodenFish = new THREE.Mesh(woodenFishGeometry, woodenFishMaterial);
            woodenFish.position.set(4, 2.75, -10);
            woodenFish.scale.set(1, 0.6, 1);
            woodenFish.castShadow = true;
            scene.add(woodenFish);
        }

        // 创建粒子效果
        function createParticleEffects() {
            // 金色光粒
            const particleGeometry = new THREE.BufferGeometry();
            const particleMaterial = new THREE.PointsMaterial({
                color: 0xffd700,
                size: 0.3,
                transparent: true,
                opacity: 0.6
            });

            const particleVertices = [];
            for (let i = 0; i < 100; i++) {
                particleVertices.push(
                    (Math.random() - 0.5) * 40,
                    Math.random() * 20,
                    (Math.random() - 0.5) * 40
                );
            }

            particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
            const particleSystem = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particleSystem);
            particles.push(particleSystem);
        }

        // 设置控制器
        function setupControls() {
            // 简单的鼠标控制
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging && currentCameraMode === 'free') {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };

                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(deltaMove.y * 0.5),
                            toRadians(deltaMove.x * 0.5),
                            0,
                            'XYZ'
                        ));

                    camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // 滚轮缩放
            renderer.domElement.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.1;
                const direction = e.deltaY > 0 ? 1 : -1;
                camera.position.multiplyScalar(1 + direction * zoomSpeed);
            });
        }

        function toRadians(angle) {
            return angle * (Math.PI / 180);
        }

        // 设置事件监听
        function setupEventListeners() {
            // 键盘事件
            document.addEventListener('keydown', onKeyDown);

            // 按钮事件
            setupButtonEvents();

            // 滑块事件
            document.getElementById('musicVolume').addEventListener('input', (e) => {
                const volume = parseInt(e.target.value);
                document.getElementById('volumeValue').textContent = volume + '%';
                setMusicVolume(volume);
            });

            // 窗口大小调整
            window.addEventListener('resize', onWindowResize);

            // 点击佛像播放钟声
            renderer.domElement.addEventListener('click', (event) => {
                // 首次用户交互时启动音频上下文
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                const mouse = new THREE.Vector2();
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, camera);

                if (buddha) {
                    const intersects = raycaster.intersectObject(buddha, true);
                    if (intersects.length > 0) {
                        // 点击佛像时的特殊效果
                        triggerBuddhaClickEffect();
                        
                        // 播放背景音乐
                        if (backgroundMusic && backgroundMusic.paused && isSoundOn) {
                            backgroundMusic.play().catch(console.error);
                        }
                    }
                }
            });

            // 移除定期播放环境音效的逻辑，因为现在只播放背景音乐
        }

        // 设置按钮事件
        function setupButtonEvents() {
            // 视角控制
            document.getElementById('cameraFree').addEventListener('click', () => setCameraMode('free'));
            document.getElementById('cameraFront').addEventListener('click', () => setCameraMode('front'));
            document.getElementById('cameraSide').addEventListener('click', () => setCameraMode('side'));
            document.getElementById('cameraTop').addEventListener('click', () => setCameraMode('top'));

            // 灯光控制
            document.getElementById('lightWarm').addEventListener('click', () => setLightMode('warm'));
            document.getElementById('lightCool').addEventListener('click', () => setLightMode('cool'));
            document.getElementById('lightGolden').addEventListener('click', () => setLightMode('golden'));
            document.getElementById('lightCandle').addEventListener('click', () => setLightMode('candle'));

            // 场景元素控制
            document.getElementById('toggleIncense').addEventListener('click', toggleIncense);
            document.getElementById('toggleLotus').addEventListener('click', toggleLotus);
            document.getElementById('toggleParticles').addEventListener('click', toggleParticles);
            document.getElementById('toggleSound').addEventListener('click', toggleSound);
        }

        // 键盘事件处理
        function onKeyDown(event) {
            switch(event.code) {
                case 'Space':
                    event.preventDefault();
                    toggleMeditation();
                    break;
                case 'KeyR':
                    resetCamera();
                    break;
                case 'Digit1':
                    setCameraMode('free');
                    break;
                case 'Digit2':
                    setCameraMode('front');
                    break;
                case 'Digit3':
                    setCameraMode('side');
                    break;
                case 'Digit4':
                    setCameraMode('top');
                    break;
                case 'KeyI':
                    toggleIncense();
                    break;
                case 'KeyL':
                    toggleLotus();
                    break;
                case 'KeyP':
                    toggleParticles();
                    break;
                case 'KeyM':
                    toggleSound();
                    break;
                case 'KeyF':
                    toggleFullscreen();
                    break;
            }
        }

        // 设置相机模式
        function setCameraMode(mode) {
            currentCameraMode = mode;
            
            // 更新按钮状态
            document.querySelectorAll('#controls button').forEach(btn => {
                if (btn.id.includes('camera')) {
                    btn.classList.remove('active');
                }
            });
            
            const modeNames = {
                'free': '自由视角',
                'front': '正面视角',
                'side': '侧面视角',
                'top': '俯视视角'
            };
            
            document.getElementById('camera' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
            document.getElementById('cameraMode').textContent = modeNames[mode];

            // 设置相机位置
            switch(mode) {
                case 'front':
                    camera.position.set(0, 10, 25);
                    camera.lookAt(0, 5, -15);
                    break;
                case 'side':
                    camera.position.set(25, 10, 0);
                    camera.lookAt(0, 5, -15);
                    break;
                case 'top':
                    camera.position.set(0, 40, 0);
                    camera.lookAt(0, 0, -15);
                    break;
                case 'free':
                default:
                    camera.position.set(0, 15, 30);
                    camera.lookAt(0, 5, -15);
                    break;
            }
        }

        // 设置灯光模式
        function setLightMode(mode) {
            currentLightMode = mode;
            
            // 更新按钮状态
            document.querySelectorAll('#controls button').forEach(btn => {
                if (btn.id.includes('light')) {
                    btn.classList.remove('active');
                }
            });
            
            document.getElementById('light' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');

            const modeNames = {
                'warm': '温暖',
                'cool': '清冷',
                'golden': '金辉',
                'candle': '烛光'
            };
            
            document.getElementById('lightMode').textContent = modeNames[mode];

            // 调整光照颜色、强度和雾效
            switch(mode) {
                case 'warm':
                    // 温暖模式 - 暖黄色调
                    ambientLight.color.setHex(0x604040);
                    ambientLight.intensity = 0.4;
                    mainLight.color.setHex(0xffd700);
                    mainLight.intensity = 0.8;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0xffd700);
                        light.intensity = index === 0 ? 1.2 : 0.6; // 佛像背光更亮
                    });
                    scene.fog.color.setHex(0x3c2010);
                    renderer.setClearColor(0x3c2010);
                    break;
                    
                case 'cool':
                    // 清冷模式 - 蓝白色调
                    ambientLight.color.setHex(0x404060);
                    ambientLight.intensity = 0.5;
                    mainLight.color.setHex(0x87ceeb);
                    mainLight.intensity = 0.9;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0x87ceeb);
                        light.intensity = index === 0 ? 1.0 : 0.8;
                    });
                    scene.fog.color.setHex(0x1a1a2e);
                    renderer.setClearColor(0x1a1a2e);
                    break;
                    
                case 'golden':
                    // 金辉模式 - 强烈金色
                    ambientLight.color.setHex(0x806040);
                    ambientLight.intensity = 0.6;
                    mainLight.color.setHex(0xffd700);
                    mainLight.intensity = 1.2;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0xffd700);
                        light.intensity = index === 0 ? 1.5 : 0.9; // 更强的金色光芒
                    });
                    scene.fog.color.setHex(0x4a3520);
                    renderer.setClearColor(0x4a3520);
                    break;
                    
                case 'candle':
                    // 烛光模式 - 昏暗橙红色
                    ambientLight.color.setHex(0x302020);
                    ambientLight.intensity = 0.2;
                    mainLight.color.setHex(0xff4400);
                    mainLight.intensity = 0.4;
                    pointLights.forEach((light, index) => {
                        light.color.setHex(0xff4400);
                        light.intensity = index === 0 ? 0.8 : 0.4; // 更暗的烛光效果
                    });
                    scene.fog.color.setHex(0x2a1510);
                    renderer.setClearColor(0x2a1510);
                    break;
            }
            
            console.log(`切换到${modeNames[mode]}模式`);
        }

        // 佛像点击特效
        function triggerBuddhaClickEffect() {
            if (!buddha) return;

            // 1. 光环闪烁效果
            buddha.children.forEach(child => {
                if (child.geometry instanceof THREE.RingGeometry) {
                    const originalEmissive = child.material.emissive.clone();
                    child.material.emissive.setHex(0xffd700);
                    
                    // 渐变恢复原色
                    let intensity = 1.0;
                    const fadeInterval = setInterval(() => {
                        intensity -= 0.05;
                        if (intensity <= 0) {
                            child.material.emissive.copy(originalEmissive);
                            clearInterval(fadeInterval);
                        } else {
                            child.material.emissive.setRGB(
                                originalEmissive.r + (1 - originalEmissive.r) * intensity,
                                originalEmissive.g + (0.84 - originalEmissive.g) * intensity,
                                originalEmissive.b + (0 - originalEmissive.b) * intensity
                            );
                        }
                    }, 50);
                }
            });

            // 2. 佛像震动效果
            const originalPosition = buddha.position.clone();
            let shakeTime = 0;
            const shakeIntensity = 0.1;
            const shakeDuration = 500; // 毫秒
            
            const shakeInterval = setInterval(() => {
                shakeTime += 16; // 约60fps
                if (shakeTime >= shakeDuration) {
                    buddha.position.copy(originalPosition);
                    clearInterval(shakeInterval);
                } else {
                    const progress = shakeTime / shakeDuration;
                    const currentIntensity = shakeIntensity * (1 - progress);
                    buddha.position.x = originalPosition.x + (Math.random() - 0.5) * currentIntensity;
                    buddha.position.y = originalPosition.y + (Math.random() - 0.5) * currentIntensity;
                    buddha.position.z = originalPosition.z + (Math.random() - 0.5) * currentIntensity;
                }
            }, 16);

            // 3. 创建点击粒子爆发效果
            createClickParticles(buddha.position);

            // 4. 临时增强佛像背光
            if (pointLights.length > 0) {
                const buddhaLight = pointLights[0]; // 佛像背光
                const originalIntensity = buddhaLight.intensity;
                buddhaLight.intensity = originalIntensity * 2;
                
                setTimeout(() => {
                    buddhaLight.intensity = originalIntensity;
                }, 1000);
            }

            console.log('佛像被点击，触发特殊效果');
        }

        // 创建点击粒子效果
        function createClickParticles(position) {
            const particleCount = 20;
            const clickParticles = [];

            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.05, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: 0xffd700,
                    transparent: true,
                    opacity: 1.0
                });
                
                const particle = new THREE.Mesh(geometry, material);
                particle.position.copy(position);
                particle.position.y += 5; // 从佛像头部位置开始
                
                // 随机方向
                const direction = new THREE.Vector3(
                    (Math.random() - 0.5) * 2,
                    Math.random() * 2 + 1,
                    (Math.random() - 0.5) * 2
                ).normalize();
                
                particle.userData = {
                    velocity: direction.multiplyScalar(Math.random() * 5 + 2),
                    life: 1.0,
                    decay: 0.02
                };
                
                scene.add(particle);
                clickParticles.push(particle);
            }

            // 动画粒子
            const animateParticles = () => {
                for (let i = clickParticles.length - 1; i >= 0; i--) {
                    const particle = clickParticles[i];
                    const userData = particle.userData;
                    
                    // 更新位置
                    particle.position.add(userData.velocity);
                    userData.velocity.y -= 0.1; // 重力
                    
                    // 更新生命值和透明度
                    userData.life -= userData.decay;
                    particle.material.opacity = userData.life;
                    
                    // 移除死亡粒子
                    if (userData.life <= 0) {
                        scene.remove(particle);
                        clickParticles.splice(i, 1);
                    }
                }
                
                if (clickParticles.length > 0) {
                    requestAnimationFrame(animateParticles);
                }
            };
            
            animateParticles();
        }

        // 切换香火
        function toggleIncense() {
            isIncenseOn = !isIncenseOn;
            document.getElementById('toggleIncense').classList.toggle('active', isIncenseOn);
            document.getElementById('incenseStatus').textContent = isIncenseOn ? '燃烧中' : '熄灭';
            
            incenseSmoke.forEach(smoke => {
                smoke.visible = isIncenseOn;
            });
        }

        // 切换莲花
        function toggleLotus() {
            isLotusOn = !isLotusOn;
            document.getElementById('toggleLotus').classList.toggle('active', isLotusOn);
            document.getElementById('lotusStatus').textContent = isLotusOn ? '盛开' : '凋谢';
            
            lotusFlowers.forEach(lotus => {
                lotus.visible = isLotusOn;
            });
        }

        // 切换粒子效果
        function toggleParticles() {
            isParticlesOn = !isParticlesOn;
            document.getElementById('toggleParticles').classList.toggle('active', isParticlesOn);
            
            particles.forEach(particle => {
                particle.visible = isParticlesOn;
            });
        }

        // 切换音效
        function toggleSound() {
            isSoundOn = !isSoundOn;
            document.getElementById('toggleSound').classList.toggle('active', isSoundOn);
            document.getElementById('soundStatus').textContent = isSoundOn ? '开启' : '关闭';
            
            if (isSoundOn) {
                // 开启音效 - 播放背景音乐
                if (backgroundMusic && isAudioInitialized) {
                    backgroundMusic.play().catch(error => {
                        console.error('播放音乐失败:', error);
                    });
                }
            } else {
                // 关闭音效 - 暂停背景音乐
                if (backgroundMusic) {
                    backgroundMusic.pause();
                }
            }
        }



        // 切换冥想模式
        function toggleMeditation() {
            isMeditating = !isMeditating;
            if (isMeditating) {
                meditationStartTime = Date.now();
            }
        }

        // 重置相机
        function resetCamera() {
            setCameraMode('free');
        }

        // 切换全屏
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // 更新冥想计时器
        function updateMeditationTimer() {
            if (isMeditating) {
                const elapsed = Date.now() - meditationStartTime;
                const minutes = Math.floor(elapsed / 60000);
                const seconds = Math.floor((elapsed % 60000) / 1000);
                document.getElementById('meditationTime').textContent = 
                    `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            }
        }

        // 窗口大小调整
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // 动画循环
        function animate(currentTime) {
            requestAnimationFrame(animate);

            // 计算FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }

            // 更新冥想计时器
            updateMeditationTimer();

            // 佛像动画效果
            if (buddha) {
                // 光环旋转动画 - 多层光环不同速度旋转
                buddha.children.forEach((child, index) => {
                    if (child.geometry instanceof THREE.RingGeometry) {
                        if (index === buddha.children.length - 1) {
                            // 外层光环慢速旋转
                            child.rotation.z += 0.005;
                        } else if (index === buddha.children.length - 2) {
                            // 内层光环快速旋转
                            child.rotation.z -= 0.01;
                        } else if (index === buddha.children.length - 3) {
                            // 主光环中速旋转
                            child.rotation.z += 0.008;
                        }
                    }
                });

                // 佛像整体轻微呼吸效果
                const breathScale = 1 + Math.sin(currentTime * 0.002) * 0.015;
                buddha.scale.set(breathScale, breathScale, breathScale);

                // 佛像头部轻微点头 - 更庄严的动作
                const headNode = buddha.children.find(child => 
                    child.geometry instanceof THREE.SphereGeometry && child.position.y > 7
                );
                if (headNode) {
                    headNode.rotation.x = Math.sin(currentTime * 0.0008) * 0.03;
                }

                // 光环装饰球体闪烁
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        child.material.color.getHex() === 0xffd700 && 
                        child.position.y > 8.5) {
                        child.material.opacity = 0.7 + Math.sin(currentTime * 0.01 + child.position.x) * 0.3;
                    }
                });

                // 胸部装饰发光效果 - 法轮发光
                const chestOrnament = buddha.children.find(child => 
                    child.geometry instanceof THREE.CylinderGeometry && 
                    child.material.color.getHex() === 0xFF6347
                );
                if (chestOrnament) {
                    const glowIntensity = 0.8 + Math.sin(currentTime * 0.003) * 0.2;
                    chestOrnament.material.emissive.setRGB(glowIntensity * 0.3, 0, 0);
                }

                // 莲花座花瓣轻微摆动
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        (child.material.color.getHex() === 0xFF1493 || 
                         child.material.color.getHex() === 0xFF69B4 || 
                         child.material.color.getHex() === 0xFFB6C1)) {
                        const originalY = child.userData.originalY || child.position.y;
                        child.userData.originalY = originalY;
                        child.position.y = originalY + Math.sin(currentTime * 0.004 + child.position.x) * 0.05;
                        child.rotation.z = Math.sin(currentTime * 0.003 + child.position.z) * 0.05;
                    }
                });

                // 打坐手印轻微摆动 - 禅定状态的微动
                buddha.children.forEach(child => {
                    // 手部动画
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        Math.abs(child.position.x) < 0.5 && 
                        child.position.y > 3 && child.position.y < 4) {
                        const side = child.position.x > 0 ? 1 : -1;
                        const originalY = child.userData.originalY || child.position.y;
                        child.userData.originalY = originalY;
                        child.position.y = originalY + Math.sin(currentTime * 0.001 + side) * 0.02;
                    }
                    
                    // 手臂轻微呼吸摆动
                    if (child.geometry instanceof THREE.CylinderGeometry && 
                        Math.abs(child.position.x) > 1.5 && child.position.y > 4) {
                        const side = child.position.x > 0 ? 1 : -1;
                        child.rotation.z = side * (Math.PI / 8 + Math.sin(currentTime * 0.0015) * 0.02);
                    }
                });

                // 盘腿坐姿的腿部轻微调整
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.CylinderGeometry && 
                        child.position.y < 3.5 && Math.abs(child.position.x) > 1) {
                        const side = child.position.x > 0 ? 1 : -1;
                        const originalRotationZ = child.userData.originalRotationZ || child.rotation.z;
                        child.userData.originalRotationZ = originalRotationZ;
                        child.rotation.z = originalRotationZ + Math.sin(currentTime * 0.001) * 0.01 * side;
                    }
                });

                // 脚部轻微摆动
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.SphereGeometry && 
                        child.position.y < 2.5 && Math.abs(child.position.x) > 2) {
                        const originalY = child.userData.originalY || child.position.y;
                        child.userData.originalY = originalY;
                        child.position.y = originalY + Math.sin(currentTime * 0.002 + child.position.x) * 0.01;
                    }
                });

                // 手指细节动画 - 禅定印的微动
                buddha.children.forEach(child => {
                    if (child.geometry instanceof THREE.CylinderGeometry && 
                        child.geometry.parameters && 
                        child.geometry.parameters.radiusTop < 0.1) {
                        const originalRotationX = child.userData.originalRotationX || child.rotation.x;
                        child.userData.originalRotationX = originalRotationX;
                        child.rotation.x = originalRotationX + Math.sin(currentTime * 0.003 + child.position.x * 10) * 0.02;
                    }
                });
            }

            // 莲花浮动动画
            lotusFlowers.forEach((lotus, index) => {
                if (lotus.visible) {
                    lotus.position.y = 0.5 + Math.sin(currentTime * 0.001 + index) * 0.1;
                    lotus.rotation.y += 0.005;
                }
            });

            // 粒子动画
            particles.forEach(particle => {
                if (particle.visible) {
                    const positions = particle.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += 0.02; // 向上飘动
                        if (positions[i] > 20) {
                            positions[i] = 0; // 重置到底部
                        }
                    }
                    particle.geometry.attributes.position.needsUpdate = true;
                    particle.rotation.y += 0.002;
                }
            });

            // 香烟动画
            if (isIncenseOn) {
                incenseSmoke.forEach(smoke => {
                    const positions = smoke.geometry.attributes.position.array;
                    for (let i = 1; i < positions.length; i += 3) {
                        positions[i] += 0.05; // 向上飘动
                        if (positions[i] > 20) {
                            positions[i] = 7.25; // 重置到香的顶端
                        }
                    }
                    smoke.geometry.attributes.position.needsUpdate = true;
                });
            }

            // 蜡烛光源闪烁
            pointLights.forEach((light, index) => {
                if (index > 0) { // 跳过佛像背光
                    light.intensity = 0.5 + Math.sin(currentTime * 0.01 + index) * 0.1;
                }
            });

            // 渲染场景
            renderer.render(scene, camera);
        }

        // 启动应用
        init();
    </script>
</body>
</html>