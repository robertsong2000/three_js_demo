<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸµ Three.js 3DéŸ³é¢‘å¯è§†åŒ–å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 50%, #16213e 100%);
            overflow: hidden;
            color: white;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            min-width: 250px;
        }

        #info h1 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
        }

        .info-item {
            margin: 5px 0;
            font-size: 12px;
            display: flex;
            justify-content: space-between;
        }

        .info-label {
            color: #aaa;
        }

        .info-value {
            color: #00ff88;
            font-weight: bold;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .control-group {
            margin: 10px 0;
        }

        .control-group label {
            display: block;
            color: #aaa;
            margin-bottom: 5px;
            font-size: 12px;
        }

        button {
            background: linear-gradient(45deg, #00ffff, #0088ff);
            border: none;
            color: white;
            padding: 8px 15px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            box-shadow: 0 0 20px rgba(255, 107, 107, 0.5);
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
        }

        input[type="file"] {
            width: 100%;
            padding: 5px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            color: white;
            font-size: 12px;
        }

        #instructions {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
            max-width: 300px;
        }

        #instructions h3 {
            color: #00ffff;
            margin-bottom: 10px;
            font-size: 14px;
        }

        #instructions ul {
            list-style: none;
            font-size: 11px;
            line-height: 1.4;
        }

        #instructions li {
            margin: 3px 0;
            color: #ccc;
        }

        #instructions .key {
            color: #00ff88;
            font-weight: bold;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 200;
            text-align: center;
            color: #00ffff;
            font-size: 18px;
        }

        .loading.hidden {
            display: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="loading" class="loading">
            <div class="pulse">ğŸµ åˆå§‹åŒ–éŸ³é¢‘å¯è§†åŒ–å™¨...</div>
            <div style="font-size: 12px; margin-top: 10px; color: #aaa;">
                è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶æˆ–ä½¿ç”¨éº¦å…‹é£è¾“å…¥
            </div>
        </div>

        <div id="info">
            <h1>ğŸµ éŸ³é¢‘å¯è§†åŒ–å™¨</h1>
            <div class="info-item">
                <span class="info-label">éŸ³é¢‘çŠ¶æ€:</span>
                <span class="info-value" id="audioStatus">æœªåŠ è½½</span>
            </div>
            <div class="info-item">
                <span class="info-label">å¯è§†åŒ–æ¨¡å¼:</span>
                <span class="info-value" id="visualMode">é¢‘è°±æŸ±çŠ¶å›¾</span>
            </div>
            <div class="info-item">
                <span class="info-label">é¢‘ç‡èŒƒå›´:</span>
                <span class="info-value" id="freqRange">20Hz - 20kHz</span>
            </div>
            <div class="info-item">
                <span class="info-label">éŸ³é‡:</span>
                <span class="info-value" id="volume">0%</span>
            </div>
            <div class="info-item">
                <span class="info-label">ä¸»é¢‘ç‡:</span>
                <span class="info-value" id="dominantFreq">0 Hz</span>
            </div>
            <div class="info-item">
                <span class="info-label">FPS:</span>
                <span class="info-value" id="fps">60</span>
            </div>
        </div>

        <div id="controls">
            <div class="control-group">
                <label>éŸ³é¢‘æº</label>
                <input type="file" id="audioFile" accept="audio/*">
                <button id="micBtn">ğŸ¤ ä½¿ç”¨éº¦å…‹é£</button>
                <button id="playBtn" disabled>â–¶ï¸ æ’­æ”¾</button>
                <button id="pauseBtn" disabled>â¸ï¸ æš‚åœ</button>
            </div>

            <div class="control-group">
                <label>å¯è§†åŒ–æ¨¡å¼</label>
                <button id="modeSpectrum" class="active">é¢‘è°±æŸ±çŠ¶å›¾</button>
                <button id="modeWave">æ³¢å½¢å›¾</button>
                <button id="modeSphere">çƒå½¢é¢‘è°±</button>
                <button id="modeRing">ç¯å½¢é¢‘è°±</button>
            </div>

            <div class="control-group">
                <label>çµæ•åº¦: <span id="sensitivityValue">1.0</span></label>
                <input type="range" id="sensitivity" min="0.1" max="3.0" step="0.1" value="1.0">
            </div>

            <div class="control-group">
                <label>å¹³æ»‘åº¦: <span id="smoothingValue">0.8</span></label>
                <input type="range" id="smoothing" min="0" max="0.95" step="0.05" value="0.8">
            </div>
        </div>

        <div id="instructions">
            <h3>ğŸ® æ“ä½œè¯´æ˜</h3>
            <ul>
                <li><span class="key">é¼ æ ‡æ‹–æ‹½</span> - æ—‹è½¬è§†è§’</li>
                <li><span class="key">æ»šè½®</span> - ç¼©æ”¾è§†è·</li>
                <li><span class="key">ç©ºæ ¼é”®</span> - æš‚åœ/ç»§ç»­</li>
                <li><span class="key">1-4é”®</span> - åˆ‡æ¢å¯è§†åŒ–æ¨¡å¼</li>
                <li><span class="key">Ré”®</span> - é‡ç½®è§†è§’</li>
                <li><span class="key">Fé”®</span> - å…¨å±æ¨¡å¼</li>
                <li><span class="key">Cé”®</span> - åˆ‡æ¢é¢œè‰²ä¸»é¢˜</li>
            </ul>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls;
        let audioContext, analyser, dataArray, bufferLength;
        let audioElement, source, microphone;
        let visualizers = [];
        let currentMode = 'spectrum';
        let isPlaying = false;
        let sensitivity = 1.0;
        let smoothingTimeConstant = 0.8;
        let colorTheme = 0;
        let frameCount = 0;
        let lastTime = 0;
        let fps = 60;

        // é¢œè‰²ä¸»é¢˜
        const colorThemes = [
            { // é’è“ä¸»é¢˜
                primary: [0, 1, 1],
                secondary: [0, 0.5, 1],
                accent: [0, 1, 0.5]
            },
            { // å½©è™¹ä¸»é¢˜
                primary: [1, 0, 0],
                secondary: [0, 1, 0],
                accent: [0, 0, 1]
            },
            { // ç´«ç²‰ä¸»é¢˜
                primary: [1, 0, 1],
                secondary: [0.5, 0, 1],
                accent: [1, 0, 0.5]
            },
            { // æ©™é»„ä¸»é¢˜
                primary: [1, 0.5, 0],
                secondary: [1, 1, 0],
                accent: [1, 0, 0]
            }
        ];

        // åˆå§‹åŒ–
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 100);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);

            // æ·»åŠ å…‰ç…§
            setupLighting();

            // åˆ›å»ºç®€å•çš„è½¨é“æ§åˆ¶
            setupControls();

            // è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // éšè—åŠ è½½ç•Œé¢
            document.getElementById('loading').classList.add('hidden');

            // å¼€å§‹æ¸²æŸ“å¾ªç¯
            animate();
        }

        // è®¾ç½®å…‰ç…§
        function setupLighting() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0x404040, 0.3);
            scene.add(ambientLight);

            // ä¸»å…‰æº
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            // ç‚¹å…‰æºï¼ˆåŠ¨æ€ï¼‰
            const pointLight = new THREE.PointLight(0x00ffff, 1, 200);
            pointLight.position.set(0, 50, 0);
            scene.add(pointLight);
        }

        // è®¾ç½®æ§åˆ¶
        function setupControls() {
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            renderer.domElement.addEventListener('mousedown', (e) => {
                isDragging = true;
                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            renderer.domElement.addEventListener('mousemove', (e) => {
                if (isDragging) {
                    const deltaMove = {
                        x: e.clientX - previousMousePosition.x,
                        y: e.clientY - previousMousePosition.y
                    };

                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            toRadians(deltaMove.y * 0.5),
                            toRadians(deltaMove.x * 0.5),
                            0,
                            'XYZ'
                        ));

                    camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, camera.quaternion);
                    previousMousePosition = { x: e.clientX, y: e.clientY };
                }
            });

            renderer.domElement.addEventListener('mouseup', () => {
                isDragging = false;
            });

            renderer.domElement.addEventListener('wheel', (e) => {
                const zoomSpeed = 0.1;
                const direction = e.deltaY > 0 ? 1 : -1;
                camera.position.multiplyScalar(1 + direction * zoomSpeed);
            });

            function toRadians(angle) {
                return angle * (Math.PI / 180);
            }
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // æ–‡ä»¶é€‰æ‹©
            document.getElementById('audioFile').addEventListener('change', handleFileSelect);

            // éº¦å…‹é£
            document.getElementById('micBtn').addEventListener('click', setupMicrophone);

            // æ’­æ”¾æ§åˆ¶
            document.getElementById('playBtn').addEventListener('click', playAudio);
            document.getElementById('pauseBtn').addEventListener('click', pauseAudio);

            // æ¨¡å¼åˆ‡æ¢
            document.getElementById('modeSpectrum').addEventListener('click', () => setMode('spectrum'));
            document.getElementById('modeWave').addEventListener('click', () => setMode('wave'));
            document.getElementById('modeSphere').addEventListener('click', () => setMode('sphere'));
            document.getElementById('modeRing').addEventListener('click', () => setMode('ring'));

            // å‚æ•°æ§åˆ¶
            document.getElementById('sensitivity').addEventListener('input', (e) => {
                sensitivity = parseFloat(e.target.value);
                document.getElementById('sensitivityValue').textContent = sensitivity.toFixed(1);
            });

            document.getElementById('smoothing').addEventListener('input', (e) => {
                smoothingTimeConstant = parseFloat(e.target.value);
                if (analyser) {
                    analyser.smoothingTimeConstant = smoothingTimeConstant;
                }
                document.getElementById('smoothingValue').textContent = smoothingTimeConstant.toFixed(2);
            });

            // é”®ç›˜æ§åˆ¶
            document.addEventListener('keydown', (e) => {
                switch(e.code) {
                    case 'Space':
                        e.preventDefault();
                        if (isPlaying) pauseAudio();
                        else playAudio();
                        break;
                    case 'Digit1':
                        setMode('spectrum');
                        break;
                    case 'Digit2':
                        setMode('wave');
                        break;
                    case 'Digit3':
                        setMode('sphere');
                        break;
                    case 'Digit4':
                        setMode('ring');
                        break;
                    case 'KeyR':
                        resetCamera();
                        break;
                    case 'KeyF':
                        toggleFullscreen();
                        break;
                    case 'KeyC':
                        cycleColorTheme();
                        break;
                }
            });

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (file) {
                const url = URL.createObjectURL(file);
                setupAudio(url);
                document.getElementById('audioStatus').textContent = file.name;
            }
        }

        // è®¾ç½®éŸ³é¢‘
        function setupAudio(url) {
            if (audioElement) {
                audioElement.pause();
                audioElement = null;
            }

            audioElement = new Audio(url);
            audioElement.crossOrigin = 'anonymous';
            audioElement.loop = true;

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 512;
                analyser.smoothingTimeConstant = smoothingTimeConstant;
                bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
            }

            source = audioContext.createMediaElementSource(audioElement);
            source.connect(analyser);
            analyser.connect(audioContext.destination);

            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;

            createVisualizers();
        }

        // è®¾ç½®éº¦å…‹é£
        async function setupMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 512;
                    analyser.smoothingTimeConstant = smoothingTimeConstant;
                    bufferLength = analyser.frequencyBinCount;
                    dataArray = new Uint8Array(bufferLength);
                }

                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                document.getElementById('audioStatus').textContent = 'éº¦å…‹é£è¾“å…¥';
                isPlaying = true;
                createVisualizers();

            } catch (err) {
                console.error('æ— æ³•è®¿é—®éº¦å…‹é£:', err);
                alert('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æƒé™è®¾ç½®');
            }
        }

        // æ’­æ”¾éŸ³é¢‘
        function playAudio() {
            if (audioElement && audioContext) {
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                audioElement.play();
                isPlaying = true;
                document.getElementById('audioStatus').textContent = 'æ’­æ”¾ä¸­';
            }
        }

        // æš‚åœéŸ³é¢‘
        function pauseAudio() {
            if (audioElement) {
                audioElement.pause();
                isPlaying = false;
                document.getElementById('audioStatus').textContent = 'å·²æš‚åœ';
            }
        }

        // è®¾ç½®æ¨¡å¼
        function setMode(mode) {
            currentMode = mode;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('#controls button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const modeNames = {
                'spectrum': 'é¢‘è°±æŸ±çŠ¶å›¾',
                'wave': 'æ³¢å½¢å›¾',
                'sphere': 'çƒå½¢é¢‘è°±',
                'ring': 'ç¯å½¢é¢‘è°±'
            };
            
            document.getElementById('mode' + mode.charAt(0).toUpperCase() + mode.slice(1)).classList.add('active');
            document.getElementById('visualMode').textContent = modeNames[mode];
            
            createVisualizers();
        }

        // åˆ›å»ºå¯è§†åŒ–å™¨
        function createVisualizers() {
            // æ¸…é™¤ç°æœ‰çš„å¯è§†åŒ–å™¨
            visualizers.forEach(obj => {
                scene.remove(obj);
            });
            visualizers = [];

            if (!bufferLength) return;

            switch(currentMode) {
                case 'spectrum':
                    createSpectrumBars();
                    break;
                case 'wave':
                    createWaveform();
                    break;
                case 'sphere':
                    createSphericalSpectrum();
                    break;
                case 'ring':
                    createRingSpectrum();
                    break;
            }
        }

        // åˆ›å»ºé¢‘è°±æŸ±çŠ¶å›¾
        function createSpectrumBars() {
            const barWidth = 2;
            const barSpacing = 0.5;
            const totalWidth = (barWidth + barSpacing) * bufferLength;
            
            for (let i = 0; i < bufferLength; i++) {
                const geometry = new THREE.BoxGeometry(barWidth, 1, barWidth);
                const material = new THREE.MeshPhongMaterial({
                    color: new THREE.Color().setHSL(i / bufferLength, 1, 0.5),
                    transparent: true,
                    opacity: 0.8
                });
                
                const bar = new THREE.Mesh(geometry, material);
                bar.position.x = (i * (barWidth + barSpacing)) - totalWidth / 2;
                bar.position.y = 0;
                
                scene.add(bar);
                visualizers.push(bar);
            }
        }

        // åˆ›å»ºæ³¢å½¢å›¾
        function createWaveform() {
            const points = [];
            for (let i = 0; i < bufferLength; i++) {
                points.push(new THREE.Vector3(
                    (i / bufferLength) * 200 - 100,
                    0,
                    0
                ));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({
                color: 0x00ffff,
                linewidth: 3
            });
            
            const line = new THREE.Line(geometry, material);
            scene.add(line);
            visualizers.push(line);
        }

        // åˆ›å»ºçƒå½¢é¢‘è°±
        function createSphericalSpectrum() {
            const radius = 30;
            const segments = Math.min(bufferLength, 64);
            
            for (let i = 0; i < segments; i++) {
                const phi = (i / segments) * Math.PI * 2;
                
                for (let j = 0; j < 8; j++) {
                    const theta = (j / 8) * Math.PI;
                    
                    const geometry = new THREE.SphereGeometry(0.5, 8, 8);
                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL((i + j) / (segments + 8), 1, 0.5),
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.x = radius * Math.sin(theta) * Math.cos(phi);
                    sphere.position.y = radius * Math.cos(theta);
                    sphere.position.z = radius * Math.sin(theta) * Math.sin(phi);
                    
                    scene.add(sphere);
                    visualizers.push(sphere);
                }
            }
        }

        // åˆ›å»ºç¯å½¢é¢‘è°±
        function createRingSpectrum() {
            const radius = 40;
            const rings = 5;
            
            for (let ring = 0; ring < rings; ring++) {
                const ringRadius = radius + ring * 10;
                const segments = Math.floor(bufferLength / rings);
                
                for (let i = 0; i < segments; i++) {
                    const angle = (i / segments) * Math.PI * 2;
                    
                    const geometry = new THREE.CylinderGeometry(1, 1, 1, 8);
                    const material = new THREE.MeshPhongMaterial({
                        color: new THREE.Color().setHSL((ring * segments + i) / bufferLength, 1, 0.5),
                        transparent: true,
                        opacity: 0.8
                    });
                    
                    const cylinder = new THREE.Mesh(geometry, material);
                    cylinder.position.x = ringRadius * Math.cos(angle);
                    cylinder.position.z = ringRadius * Math.sin(angle);
                    cylinder.position.y = 0;
                    
                    scene.add(cylinder);
                    visualizers.push(cylinder);
                }
            }
        }

        // æ›´æ–°å¯è§†åŒ–
        function updateVisualization() {
            if (!analyser || !dataArray) return;

            analyser.getByteFrequencyData(dataArray);

            // è®¡ç®—éŸ³é‡å’Œä¸»é¢‘ç‡
            let sum = 0;
            let maxValue = 0;
            let maxIndex = 0;
            
            for (let i = 0; i < bufferLength; i++) {
                sum += dataArray[i];
                if (dataArray[i] > maxValue) {
                    maxValue = dataArray[i];
                    maxIndex = i;
                }
            }
            
            const volume = Math.round((sum / bufferLength / 255) * 100);
            const dominantFreq = Math.round((maxIndex / bufferLength) * (audioContext.sampleRate / 2));
            
            document.getElementById('volume').textContent = volume + '%';
            document.getElementById('dominantFreq').textContent = dominantFreq + ' Hz';

            // æ›´æ–°å¯è§†åŒ–å™¨
            switch(currentMode) {
                case 'spectrum':
                    updateSpectrumBars();
                    break;
                case 'wave':
                    updateWaveform();
                    break;
                case 'sphere':
                    updateSphericalSpectrum();
                    break;
                case 'ring':
                    updateRingSpectrum();
                    break;
            }
        }

        // æ›´æ–°é¢‘è°±æŸ±çŠ¶å›¾
        function updateSpectrumBars() {
            for (let i = 0; i < Math.min(visualizers.length, bufferLength); i++) {
                const bar = visualizers[i];
                const value = dataArray[i] / 255 * sensitivity;
                
                bar.scale.y = Math.max(0.1, value * 50);
                bar.position.y = bar.scale.y / 2;
                
                // æ›´æ–°é¢œè‰²
                const theme = colorThemes[colorTheme];
                const hue = (i / bufferLength + frameCount * 0.01) % 1;
                bar.material.color.setHSL(hue, 1, 0.5 + value * 0.3);
            }
        }

        // æ›´æ–°æ³¢å½¢å›¾
        function updateWaveform() {
            if (visualizers.length > 0) {
                const line = visualizers[0];
                const positions = line.geometry.attributes.position.array;
                
                for (let i = 0; i < bufferLength; i++) {
                    const value = (dataArray[i] / 255 - 0.5) * sensitivity * 50;
                    positions[i * 3 + 1] = value; // Yåæ ‡
                }
                
                line.geometry.attributes.position.needsUpdate = true;
            }
        }

        // æ›´æ–°çƒå½¢é¢‘è°±
        function updateSphericalSpectrum() {
            const segments = Math.min(Math.floor(visualizers.length / 8), bufferLength);
            
            for (let i = 0; i < segments; i++) {
                const value = dataArray[i] / 255 * sensitivity;
                
                for (let j = 0; j < 8; j++) {
                    const index = i * 8 + j;
                    if (index < visualizers.length) {
                        const sphere = visualizers[index];
                        sphere.scale.setScalar(0.5 + value * 3);
                        
                        // æ›´æ–°é¢œè‰²
                        const hue = (i / segments + frameCount * 0.01) % 1;
                        sphere.material.color.setHSL(hue, 1, 0.5 + value * 0.3);
                    }
                }
            }
        }

        // æ›´æ–°ç¯å½¢é¢‘è°±
        function updateRingSpectrum() {
            const rings = 5;
            const segments = Math.floor(bufferLength / rings);
            
            for (let ring = 0; ring < rings; ring++) {
                for (let i = 0; i < segments; i++) {
                    const dataIndex = ring * segments + i;
                    const visualIndex = ring * segments + i;
                    
                    if (dataIndex < bufferLength && visualIndex < visualizers.length) {
                        const cylinder = visualizers[visualIndex];
                        const value = dataArray[dataIndex] / 255 * sensitivity;
                        
                        cylinder.scale.y = Math.max(0.1, value * 30);
                        cylinder.position.y = cylinder.scale.y / 2;
                        
                        // æ›´æ–°é¢œè‰²
                        const hue = (dataIndex / bufferLength + frameCount * 0.01) % 1;
                        cylinder.material.color.setHSL(hue, 1, 0.5 + value * 0.3);
                    }
                }
            }
        }

        // é‡ç½®ç›¸æœº
        function resetCamera() {
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 0, 0);
        }

        // åˆ‡æ¢å…¨å±
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        // åˆ‡æ¢é¢œè‰²ä¸»é¢˜
        function cycleColorTheme() {
            colorTheme = (colorTheme + 1) % colorThemes.length;
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åŠ¨ç”»å¾ªç¯
        function animate(currentTime) {
            requestAnimationFrame(animate);

            // è®¡ç®—FPS
            frameCount++;
            if (currentTime - lastTime >= 1000) {
                fps = Math.round(frameCount * 1000 / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }

            // æ›´æ–°å¯è§†åŒ–
            if (isPlaying || microphone) {
                updateVisualization();
            }

            // æ¸²æŸ“åœºæ™¯
            renderer.render(scene, camera);
        }

        // å¯åŠ¨åº”ç”¨
        init();
    </script>
</body>
</html>