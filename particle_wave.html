<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js Particle Wave Demo - äº¤äº’å¼ç²’å­æ³¢æµª</title>
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1e3c72 0%, #2a5298 50%, #000000 100%);
            font-family: 'Arial', sans-serif;
            cursor: none;
        }
        
        #info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 15px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        #controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: white;
            font-size: 12px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 12px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #stats {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #00ff88;
            font-size: 12px;
            font-family: 'Courier New', monospace;
            z-index: 100;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.3);
        }
        
        #cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            border: 2px solid #00ff88;
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
            transition: transform 0.1s ease;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="cursor"></div>
    
    <div id="info">
        <h3>ğŸŒŠ ç²’å­æ³¢æµªæ¼”ç¤º</h3>
        <p>å®æ—¶äº¤äº’å¼3Dç²’å­ç³»ç»Ÿ</p>
        <p>é¼ æ ‡æ§åˆ¶æ³¢æµªå½¢æ€</p>
        <p id="particleCount">ç²’å­æ•°é‡: 10,000</p>
    </div>
    
    <div id="controls">
        <p>ğŸ–±ï¸ é¼ æ ‡ç§»åŠ¨: æ§åˆ¶æ³¢æµª</p>
        <p>ğŸ” æ»šè½®: è°ƒæ•´è§†è§’</p>
        <p>âŒ¨ï¸ 1-5: åˆ‡æ¢æ•ˆæœæ¨¡å¼</p>
        <p>âŒ¨ï¸ ç©ºæ ¼: æš‚åœ/ç»§ç»­</p>
        <p>âŒ¨ï¸ R: é‡ç½®æ³¢æµª</p>
    </div>
    
    <div id="stats">
        <div>FPS: <span id="fps">60</span></div>
        <div>æ¨¡å¼: <span id="mode">æ³¢æµªæ¨¡å¼</span></div>
        <div>é¼ æ ‡: <span id="mousePos">0, 0</span></div>
        <div>æ—¶é—´: <span id="timeDisplay">0.0s</span></div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let particles, particleGeometry, particleMaterial;
        let mouse = new THREE.Vector2();
        let time = 0;
        let isPaused = false;
        let currentMode = 1;
        let frameCount = 0;
        let lastTime = performance.now();
        
        // ç²’å­ç³»ç»Ÿå‚æ•°
        const PARTICLE_COUNT = 10000;
        const GRID_SIZE = 100;
        const WAVE_HEIGHT = 20;
        
        // æ¨¡å¼åç§°
        const modes = {
            1: "æ³¢æµªæ¨¡å¼",
            2: "èºæ—‹æ¨¡å¼", 
            3: "çˆ†ç‚¸æ¨¡å¼",
            4: "æ¼©æ¶¡æ¨¡å¼",
            5: "è„‰å†²æ¨¡å¼"
        };

        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000033, 100, 300);

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 50, 100);
            camera.lookAt(0, 0, 0);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.getElementById('container').appendChild(renderer.domElement);

            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            createParticleSystem();

            // åˆ›å»ºç¯å¢ƒå…‰ç…§
            setupLighting();

            // æ·»åŠ äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // å¼€å§‹åŠ¨ç”»
            animate();
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem() {
            particleGeometry = new THREE.BufferGeometry();
            
            // åˆ›å»ºç²’å­ä½ç½®æ•°ç»„
            const positions = new Float32Array(PARTICLE_COUNT * 3);
            const colors = new Float32Array(PARTICLE_COUNT * 3);
            const sizes = new Float32Array(PARTICLE_COUNT);
            
            // åˆå§‹åŒ–ç²’å­
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const i3 = i * 3;
                
                // ç½‘æ ¼åˆ†å¸ƒ
                const gridX = (i % GRID_SIZE) - GRID_SIZE / 2;
                const gridZ = Math.floor(i / GRID_SIZE) - GRID_SIZE / 2;
                
                positions[i3] = gridX * 2;
                positions[i3 + 1] = 0;
                positions[i3 + 2] = gridZ * 2;
                
                // éšæœºé¢œè‰²
                const hue = (i / PARTICLE_COUNT) * 360;
                const color = new THREE.Color().setHSL(hue / 360, 0.8, 0.6);
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;
                
                // éšæœºå¤§å°
                sizes[i] = Math.random() * 3 + 1;
            }
            
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            // åˆ›å»ºç²’å­æè´¨
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    mouse: { value: new THREE.Vector2() },
                    mode: { value: currentMode }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vAlpha;
                    uniform float time;
                    uniform vec2 mouse;
                    uniform float mode;
                    
                    void main() {
                        vColor = color;
                        
                        vec3 pos = position;
                        float distance = length(pos.xz);
                        
                        // ä¸åŒæ¨¡å¼çš„æ•ˆæœ
                        if (mode == 1.0) {
                            // æ³¢æµªæ¨¡å¼
                            float wave = sin(distance * 0.1 - time * 2.0) * 10.0;
                            float mouseWave = sin(length(pos.xz - mouse * 50.0) * 0.2 - time * 3.0) * 15.0;
                            pos.y = wave + mouseWave;
                        } else if (mode == 2.0) {
                            // èºæ—‹æ¨¡å¼
                            float angle = atan(pos.z, pos.x) + time * 0.5;
                            pos.y = sin(angle * 3.0 + distance * 0.1) * 15.0;
                        } else if (mode == 3.0) {
                            // çˆ†ç‚¸æ¨¡å¼
                            float explosion = sin(time * 2.0) * 0.5 + 0.5;
                            pos *= (1.0 + explosion * 2.0);
                            pos.y = sin(distance * 0.1 + time * 3.0) * 20.0 * explosion;
                        } else if (mode == 4.0) {
                            // æ¼©æ¶¡æ¨¡å¼
                            float angle = atan(pos.z, pos.x) + distance * 0.02 - time;
                            float radius = length(pos.xz);
                            pos.x = cos(angle) * radius;
                            pos.z = sin(angle) * radius;
                            pos.y = sin(distance * 0.1 - time * 2.0) * 10.0;
                        } else if (mode == 5.0) {
                            // è„‰å†²æ¨¡å¼
                            float pulse = sin(time * 4.0) * 0.5 + 0.5;
                            pos.y = sin(distance * 0.1 - time * 2.0) * 15.0 * pulse;
                        }
                        
                        vAlpha = 1.0 - distance / 100.0;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        float distance = length(gl_PointCoord - vec2(0.5));
                        if (distance > 0.5) discard;
                        
                        float alpha = (1.0 - distance * 2.0) * vAlpha;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // è®¾ç½®å…‰ç…§
        function setupLighting() {
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(50, 50, 50);
            scene.add(directionalLight);
        }

        // è®¾ç½®äº‹ä»¶ç›‘å¬
        function setupEventListeners() {
            // é¼ æ ‡ç§»åŠ¨
            document.addEventListener('mousemove', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                
                // æ›´æ–°è‡ªå®šä¹‰å…‰æ ‡ä½ç½®
                const cursor = document.getElementById('cursor');
                cursor.style.left = event.clientX - 10 + 'px';
                cursor.style.top = event.clientY - 10 + 'px';
                
                // æ›´æ–°é¼ æ ‡ä½ç½®æ˜¾ç¤º
                document.getElementById('mousePos').textContent = 
                    `${Math.round(mouse.x * 100)}, ${Math.round(mouse.y * 100)}`;
            });

            // æ»šè½®ç¼©æ”¾
            document.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * 0.1;
                camera.position.z = Math.max(50, Math.min(200, camera.position.z));
            });

            // é”®ç›˜äº‹ä»¶
            document.addEventListener('keydown', (event) => {
                switch(event.code) {
                    case 'Space':
                        event.preventDefault();
                        isPaused = !isPaused;
                        break;
                    case 'KeyR':
                        time = 0;
                        break;
                    case 'Digit1':
                    case 'Digit2':
                    case 'Digit3':
                    case 'Digit4':
                    case 'Digit5':
                        currentMode = parseInt(event.code.slice(-1));
                        particleMaterial.uniforms.mode.value = currentMode;
                        document.getElementById('mode').textContent = modes[currentMode];
                        break;
                }
            });

            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            frameCount++;
            const currentTime = performance.now();
            
            if (currentTime - lastTime >= 1000) {
                const fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
                document.getElementById('fps').textContent = fps;
                frameCount = 0;
                lastTime = currentTime;
            }
            
            document.getElementById('timeDisplay').textContent = time.toFixed(1) + 's';
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            if (!isPaused) {
                time += 0.016; // çº¦60fps
                
                // æ›´æ–°shader uniforms
                particleMaterial.uniforms.time.value = time;
                particleMaterial.uniforms.mouse.value = mouse;
                
                // ç›¸æœºè½»å¾®æ‘†åŠ¨
                camera.position.x = Math.sin(time * 0.2) * 10;
                camera.position.y = 50 + Math.sin(time * 0.3) * 5;
                camera.lookAt(0, 0, 0);
                
                // æ—‹è½¬ç²’å­ç³»ç»Ÿ
                particles.rotation.y += 0.002;
            }

            updateStats();
            renderer.render(scene, camera);
        }

        // å¯åŠ¨åº”ç”¨
        init();
        
        // åˆå§‹åŒ–æ¨¡å¼æ˜¾ç¤º
        document.getElementById('mode').textContent = modes[currentMode];
    </script>
</body>
</html>